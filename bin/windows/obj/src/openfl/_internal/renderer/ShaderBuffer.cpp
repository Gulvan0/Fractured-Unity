// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_ShaderBuffer
#include <openfl/_internal/renderer/ShaderBuffer.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Bool
#include <openfl/display/ShaderParameter_Bool.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Int
#include <openfl/display/ShaderParameter_Int.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_35eccd5eb8f43d1d_51_new,"openfl._internal.renderer.ShaderBuffer","new",0x33d81cf2,"openfl._internal.renderer.ShaderBuffer.new","openfl/_internal/renderer/ShaderBuffer.hx",51,0x9cbf111f)
HX_LOCAL_STACK_FRAME(_hx_pos_35eccd5eb8f43d1d_70_addOverride,"openfl._internal.renderer.ShaderBuffer","addOverride",0xcae2881f,"openfl._internal.renderer.ShaderBuffer.addOverride","openfl/_internal/renderer/ShaderBuffer.hx",70,0x9cbf111f)
HX_LOCAL_STACK_FRAME(_hx_pos_35eccd5eb8f43d1d_81_clearOverride,"openfl._internal.renderer.ShaderBuffer","clearOverride",0x43b99c0b,"openfl._internal.renderer.ShaderBuffer.clearOverride","openfl/_internal/renderer/ShaderBuffer.hx",81,0x9cbf111f)
HX_LOCAL_STACK_FRAME(_hx_pos_35eccd5eb8f43d1d_86_update,"openfl._internal.renderer.ShaderBuffer","update",0xfab9e0b7,"openfl._internal.renderer.ShaderBuffer.update","openfl/_internal/renderer/ShaderBuffer.hx",86,0x9cbf111f)
namespace openfl{
namespace _internal{
namespace renderer{

void ShaderBuffer_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_35eccd5eb8f43d1d_51_new)
HXLINE(  53)		this->inputRefs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  54)		this->inputFilter = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  55)		this->inputMipFilter = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  56)		this->inputs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  57)		this->inputWrap = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  58)		this->overrideNames = ::Array_obj< ::String >::__new(0);
HXLINE(  59)		this->overrideValues = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  60)		this->paramLengths = ::Array_obj< int >::__new(0);
HXLINE(  61)		this->paramPositions = ::Array_obj< int >::__new(0);
HXLINE(  62)		this->paramRefs_Bool = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  63)		this->paramRefs_Float = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  64)		this->paramRefs_Int = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  65)		this->paramTypes = ::Array_obj< int >::__new(0);
            	}

Dynamic ShaderBuffer_obj::__CreateEmpty() { return new ShaderBuffer_obj; }

void *ShaderBuffer_obj::_hx_vtable = 0;

Dynamic ShaderBuffer_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ShaderBuffer_obj > _hx_result = new ShaderBuffer_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ShaderBuffer_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x10b40e74;
}

void ShaderBuffer_obj::addOverride(::String name,::cpp::VirtualArray values){
            	HX_STACKFRAME(&_hx_pos_35eccd5eb8f43d1d_70_addOverride)
HXLINE(  72)		this->overrideNames[this->overrideCount] = name;
HXLINE(  73)		this->overrideValues[this->overrideCount] = values;
HXLINE(  74)		this->overrideCount++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ShaderBuffer_obj,addOverride,(void))

void ShaderBuffer_obj::clearOverride(){
            	HX_STACKFRAME(&_hx_pos_35eccd5eb8f43d1d_81_clearOverride)
HXDLIN(  81)		this->overrideCount = (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ShaderBuffer_obj,clearOverride,(void))

void ShaderBuffer_obj::update( ::openfl::display::GraphicsShader shader){
            	HX_GC_STACKFRAME(&_hx_pos_35eccd5eb8f43d1d_86_update)
HXLINE(  88)		this->inputCount = (int)0;
HXLINE(  89)		this->overrideCount = (int)0;
HXLINE(  90)		this->paramBoolCount = (int)0;
HXLINE(  91)		this->paramCount = (int)0;
HXLINE(  92)		this->paramDataLength = (int)0;
HXLINE(  93)		this->paramFloatCount = (int)0;
HXLINE(  94)		this->paramIntCount = (int)0;
HXLINE(  95)		this->shader = null();
HXLINE(  97)		if (hx::IsNull( shader )) {
HXLINE(  97)			return;
            		}
HXLINE(  99)		shader->_hx___init();
HXLINE( 101)		this->inputCount = shader->_hx___inputBitmapData->length;
HXLINE( 102)		 ::openfl::display::ShaderInput_openfl_display_BitmapData input;
HXLINE( 104)		{
HXLINE( 104)			int _g1 = (int)0;
HXDLIN( 104)			int _g = this->inputCount;
HXDLIN( 104)			while((_g1 < _g)){
HXLINE( 104)				_g1 = (_g1 + (int)1);
HXDLIN( 104)				int i = (_g1 - (int)1);
HXLINE( 106)				input = shader->_hx___inputBitmapData->__get(i).StaticCast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >();
HXLINE( 107)				this->inputs[i] = input->input;
HXLINE( 108)				this->inputFilter[i] = input->filter;
HXLINE( 109)				this->inputMipFilter[i] = input->mipFilter;
HXLINE( 110)				this->inputRefs[i] = input;
HXLINE( 111)				this->inputWrap[i] = input->wrap;
            			}
            		}
HXLINE( 115)		int boolCount = shader->_hx___paramBool->length;
HXLINE( 116)		int floatCount = shader->_hx___paramFloat->length;
HXLINE( 117)		int intCount = shader->_hx___paramInt->length;
HXLINE( 118)		this->paramCount = ((boolCount + floatCount) + intCount);
HXLINE( 119)		this->paramBoolCount = boolCount;
HXLINE( 120)		this->paramFloatCount = floatCount;
HXLINE( 121)		this->paramIntCount = intCount;
HXLINE( 123)		int paramLength = (int)0;
HXLINE( 124)		int length = (int)0;
HXDLIN( 124)		int p = (int)0;
HXLINE( 125)		 ::openfl::display::ShaderParameter_Bool param;
HXLINE( 127)		{
HXLINE( 127)			int _g11 = (int)0;
HXDLIN( 127)			int _g2 = boolCount;
HXDLIN( 127)			while((_g11 < _g2)){
HXLINE( 127)				_g11 = (_g11 + (int)1);
HXDLIN( 127)				int i1 = (_g11 - (int)1);
HXLINE( 129)				param = shader->_hx___paramBool->__get(i1).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXLINE( 131)				this->paramPositions[p] = this->paramDataLength;
HXLINE( 132)				if (hx::IsNotNull( param->value )) {
HXLINE( 132)					length = param->value->length;
            				}
            				else {
HXLINE( 132)					length = (int)0;
            				}
HXLINE( 133)				this->paramLengths[p] = length;
HXLINE( 134)				 ::openfl::_internal::renderer::ShaderBuffer _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 134)				_hx_tmp->paramDataLength = (_hx_tmp->paramDataLength + length);
HXLINE( 135)				this->paramTypes[p] = (int)0;
HXLINE( 137)				this->paramRefs_Bool[i1] = param;
HXLINE( 138)				p = (p + (int)1);
            			}
            		}
HXLINE( 142)		 ::openfl::display::ShaderParameter_Float param1;
HXLINE( 144)		{
HXLINE( 144)			int _g12 = (int)0;
HXDLIN( 144)			int _g3 = floatCount;
HXDLIN( 144)			while((_g12 < _g3)){
HXLINE( 144)				_g12 = (_g12 + (int)1);
HXDLIN( 144)				int i2 = (_g12 - (int)1);
HXLINE( 146)				param1 = shader->_hx___paramFloat->__get(i2).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXLINE( 148)				this->paramPositions[p] = this->paramDataLength;
HXLINE( 149)				if (hx::IsNotNull( param1->value )) {
HXLINE( 149)					length = param1->value->length;
            				}
            				else {
HXLINE( 149)					length = (int)0;
            				}
HXLINE( 150)				this->paramLengths[p] = length;
HXLINE( 151)				 ::openfl::_internal::renderer::ShaderBuffer _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 151)				_hx_tmp1->paramDataLength = (_hx_tmp1->paramDataLength + length);
HXLINE( 152)				this->paramTypes[p] = (int)1;
HXLINE( 154)				this->paramRefs_Float[i2] = param1;
HXLINE( 155)				p = (p + (int)1);
            			}
            		}
HXLINE( 159)		 ::openfl::display::ShaderParameter_Int param2;
HXLINE( 161)		{
HXLINE( 161)			int _g13 = (int)0;
HXDLIN( 161)			int _g4 = intCount;
HXDLIN( 161)			while((_g13 < _g4)){
HXLINE( 161)				_g13 = (_g13 + (int)1);
HXDLIN( 161)				int i3 = (_g13 - (int)1);
HXLINE( 163)				param2 = shader->_hx___paramInt->__get(i3).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXLINE( 165)				this->paramPositions[p] = this->paramDataLength;
HXLINE( 166)				if (hx::IsNotNull( param2->value )) {
HXLINE( 166)					length = param2->value->length;
            				}
            				else {
HXLINE( 166)					length = (int)0;
            				}
HXLINE( 167)				this->paramLengths[p] = length;
HXLINE( 168)				 ::openfl::_internal::renderer::ShaderBuffer _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 168)				_hx_tmp2->paramDataLength = (_hx_tmp2->paramDataLength + length);
HXLINE( 169)				this->paramTypes[p] = (int)2;
HXLINE( 171)				this->paramRefs_Int[i3] = param2;
HXLINE( 172)				p = (p + (int)1);
            			}
            		}
HXLINE( 176)		if ((this->paramDataLength > (int)0)) {
HXLINE( 178)			if (hx::IsNull( this->paramData )) {
HXLINE( 180)				 ::Dynamic elements = this->paramDataLength;
HXDLIN( 180)				 ::lime::utils::ArrayBufferView this1;
HXDLIN( 180)				if (hx::IsNotNull( elements )) {
HXLINE( 180)					this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,(int)8);
            				}
            				else {
HXLINE( 180)					HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            				}
HXDLIN( 180)				this->paramData = this1;
            			}
            			else {
HXLINE( 182)				if ((this->paramDataLength > this->paramData->length)) {
HXLINE( 184)					 ::Dynamic elements1 = this->paramDataLength;
HXDLIN( 184)					 ::lime::utils::ArrayBufferView this2;
HXDLIN( 184)					if (hx::IsNotNull( elements1 )) {
HXLINE( 184)						this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements1,(int)8);
            					}
            					else {
HXLINE( 184)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
HXDLIN( 184)					 ::lime::utils::ArrayBufferView data = this2;
HXLINE( 185)					{
HXLINE( 185)						 ::lime::utils::ArrayBufferView view = this->paramData;
HXDLIN( 185)						int offset = (int)0;
HXDLIN( 185)						if (hx::IsNotNull( view )) {
HXLINE( 185)							 ::haxe::io::Bytes data1 = data->buffer;
HXDLIN( 185)							data1->blit((offset * data->bytesPerElement),view->buffer,view->byteOffset,view->byteLength);
            						}
            						else {
HXLINE( 185)							HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            						}
            					}
HXLINE( 186)					this->paramData = data;
            				}
            			}
            		}
HXLINE( 192)		int boolIndex = (int)0;
HXLINE( 193)		int floatIndex = (int)0;
HXLINE( 194)		int intIndex = (int)0;
HXLINE( 196)		int paramPosition = (int)0;
HXLINE( 197)		 ::openfl::display::ShaderParameter_Bool boolParam;
HXDLIN( 197)		 ::openfl::display::ShaderParameter_Float floatParam;
HXDLIN( 197)		 ::openfl::display::ShaderParameter_Int intParam;
HXDLIN( 197)		int length1;
HXLINE( 199)		{
HXLINE( 199)			int _g14 = (int)0;
HXDLIN( 199)			int _g5 = this->paramCount;
HXDLIN( 199)			while((_g14 < _g5)){
HXLINE( 199)				_g14 = (_g14 + (int)1);
HXDLIN( 199)				int i4 = (_g14 - (int)1);
HXLINE( 201)				length1 = this->paramLengths->__get(i4);
HXLINE( 203)				if ((i4 < boolCount)) {
HXLINE( 205)					boolParam = this->paramRefs_Bool->__get(boolIndex).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXLINE( 206)					boolIndex = (boolIndex + (int)1);
HXLINE( 208)					{
HXLINE( 208)						int _g31 = (int)0;
HXDLIN( 208)						int _g21 = length1;
HXDLIN( 208)						while((_g31 < _g21)){
HXLINE( 208)							_g31 = (_g31 + (int)1);
HXDLIN( 208)							int j = (_g31 - (int)1);
HXLINE( 210)							{
HXLINE( 210)								 ::lime::utils::ArrayBufferView this3 = this->paramData;
HXDLIN( 210)								Float val;
HXDLIN( 210)								if (boolParam->value->__get(j)) {
HXLINE( 210)									val = (int)1;
            								}
            								else {
HXLINE( 210)									val = (int)0;
            								}
HXDLIN( 210)								{
HXLINE( 210)									int this4 = this3->byteOffset;
HXDLIN( 210)									::__hxcpp_memory_set_float(this3->buffer->b,(this4 + (paramPosition * (int)4)),val);
            								}
            							}
HXLINE( 211)							paramPosition = (paramPosition + (int)1);
            						}
            					}
            				}
            				else {
HXLINE( 215)					if ((i4 < (boolCount + floatCount))) {
HXLINE( 217)						floatParam = this->paramRefs_Float->__get(floatIndex).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXLINE( 218)						floatIndex = (floatIndex + (int)1);
HXLINE( 220)						{
HXLINE( 220)							int _g32 = (int)0;
HXDLIN( 220)							int _g22 = length1;
HXDLIN( 220)							while((_g32 < _g22)){
HXLINE( 220)								_g32 = (_g32 + (int)1);
HXDLIN( 220)								int j1 = (_g32 - (int)1);
HXLINE( 222)								{
HXLINE( 222)									 ::lime::utils::ArrayBufferView this5 = this->paramData;
HXDLIN( 222)									Float val1 = floatParam->value->__get(j1);
HXDLIN( 222)									{
HXLINE( 222)										int this6 = this5->byteOffset;
HXDLIN( 222)										::__hxcpp_memory_set_float(this5->buffer->b,(this6 + (paramPosition * (int)4)),val1);
            									}
            								}
HXLINE( 223)								paramPosition = (paramPosition + (int)1);
            							}
            						}
            					}
            					else {
HXLINE( 229)						intParam = this->paramRefs_Int->__get(intIndex).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXLINE( 230)						intIndex = (intIndex + (int)1);
HXLINE( 232)						{
HXLINE( 232)							int _g33 = (int)0;
HXDLIN( 232)							int _g23 = length1;
HXDLIN( 232)							while((_g33 < _g23)){
HXLINE( 232)								_g33 = (_g33 + (int)1);
HXDLIN( 232)								int j2 = (_g33 - (int)1);
HXLINE( 234)								{
HXLINE( 234)									 ::lime::utils::ArrayBufferView this7 = this->paramData;
HXDLIN( 234)									Float val2 = intParam->value->__get(j2);
HXDLIN( 234)									{
HXLINE( 234)										int this8 = this7->byteOffset;
HXDLIN( 234)										::__hxcpp_memory_set_float(this7->buffer->b,(this8 + (paramPosition * (int)4)),val2);
            									}
            								}
HXLINE( 235)								paramPosition = (paramPosition + (int)1);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 243)		this->shader = shader;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ShaderBuffer_obj,update,(void))


hx::ObjectPtr< ShaderBuffer_obj > ShaderBuffer_obj::__new() {
	hx::ObjectPtr< ShaderBuffer_obj > __this = new ShaderBuffer_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< ShaderBuffer_obj > ShaderBuffer_obj::__alloc(hx::Ctx *_hx_ctx) {
	ShaderBuffer_obj *__this = (ShaderBuffer_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ShaderBuffer_obj), true, "openfl._internal.renderer.ShaderBuffer"));
	*(void **)__this = ShaderBuffer_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ShaderBuffer_obj::ShaderBuffer_obj()
{
}

void ShaderBuffer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ShaderBuffer);
	HX_MARK_MEMBER_NAME(inputCount,"inputCount");
	HX_MARK_MEMBER_NAME(inputRefs,"inputRefs");
	HX_MARK_MEMBER_NAME(inputFilter,"inputFilter");
	HX_MARK_MEMBER_NAME(inputMipFilter,"inputMipFilter");
	HX_MARK_MEMBER_NAME(inputs,"inputs");
	HX_MARK_MEMBER_NAME(inputWrap,"inputWrap");
	HX_MARK_MEMBER_NAME(overrideCount,"overrideCount");
	HX_MARK_MEMBER_NAME(overrideNames,"overrideNames");
	HX_MARK_MEMBER_NAME(overrideValues,"overrideValues");
	HX_MARK_MEMBER_NAME(paramBoolCount,"paramBoolCount");
	HX_MARK_MEMBER_NAME(paramCount,"paramCount");
	HX_MARK_MEMBER_NAME(paramData,"paramData");
	HX_MARK_MEMBER_NAME(paramDataBuffer,"paramDataBuffer");
	HX_MARK_MEMBER_NAME(paramDataLength,"paramDataLength");
	HX_MARK_MEMBER_NAME(paramFloatCount,"paramFloatCount");
	HX_MARK_MEMBER_NAME(paramIntCount,"paramIntCount");
	HX_MARK_MEMBER_NAME(paramLengths,"paramLengths");
	HX_MARK_MEMBER_NAME(paramPositions,"paramPositions");
	HX_MARK_MEMBER_NAME(paramRefs_Bool,"paramRefs_Bool");
	HX_MARK_MEMBER_NAME(paramRefs_Float,"paramRefs_Float");
	HX_MARK_MEMBER_NAME(paramRefs_Int,"paramRefs_Int");
	HX_MARK_MEMBER_NAME(paramTypes,"paramTypes");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_END_CLASS();
}

void ShaderBuffer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(inputCount,"inputCount");
	HX_VISIT_MEMBER_NAME(inputRefs,"inputRefs");
	HX_VISIT_MEMBER_NAME(inputFilter,"inputFilter");
	HX_VISIT_MEMBER_NAME(inputMipFilter,"inputMipFilter");
	HX_VISIT_MEMBER_NAME(inputs,"inputs");
	HX_VISIT_MEMBER_NAME(inputWrap,"inputWrap");
	HX_VISIT_MEMBER_NAME(overrideCount,"overrideCount");
	HX_VISIT_MEMBER_NAME(overrideNames,"overrideNames");
	HX_VISIT_MEMBER_NAME(overrideValues,"overrideValues");
	HX_VISIT_MEMBER_NAME(paramBoolCount,"paramBoolCount");
	HX_VISIT_MEMBER_NAME(paramCount,"paramCount");
	HX_VISIT_MEMBER_NAME(paramData,"paramData");
	HX_VISIT_MEMBER_NAME(paramDataBuffer,"paramDataBuffer");
	HX_VISIT_MEMBER_NAME(paramDataLength,"paramDataLength");
	HX_VISIT_MEMBER_NAME(paramFloatCount,"paramFloatCount");
	HX_VISIT_MEMBER_NAME(paramIntCount,"paramIntCount");
	HX_VISIT_MEMBER_NAME(paramLengths,"paramLengths");
	HX_VISIT_MEMBER_NAME(paramPositions,"paramPositions");
	HX_VISIT_MEMBER_NAME(paramRefs_Bool,"paramRefs_Bool");
	HX_VISIT_MEMBER_NAME(paramRefs_Float,"paramRefs_Float");
	HX_VISIT_MEMBER_NAME(paramRefs_Int,"paramRefs_Int");
	HX_VISIT_MEMBER_NAME(paramTypes,"paramTypes");
	HX_VISIT_MEMBER_NAME(shader,"shader");
}

hx::Val ShaderBuffer_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"inputs") ) { return hx::Val( inputs ); }
		if (HX_FIELD_EQ(inName,"shader") ) { return hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"inputRefs") ) { return hx::Val( inputRefs ); }
		if (HX_FIELD_EQ(inName,"inputWrap") ) { return hx::Val( inputWrap ); }
		if (HX_FIELD_EQ(inName,"paramData") ) { return hx::Val( paramData ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"inputCount") ) { return hx::Val( inputCount ); }
		if (HX_FIELD_EQ(inName,"paramCount") ) { return hx::Val( paramCount ); }
		if (HX_FIELD_EQ(inName,"paramTypes") ) { return hx::Val( paramTypes ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"inputFilter") ) { return hx::Val( inputFilter ); }
		if (HX_FIELD_EQ(inName,"addOverride") ) { return hx::Val( addOverride_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"paramLengths") ) { return hx::Val( paramLengths ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"overrideCount") ) { return hx::Val( overrideCount ); }
		if (HX_FIELD_EQ(inName,"overrideNames") ) { return hx::Val( overrideNames ); }
		if (HX_FIELD_EQ(inName,"paramIntCount") ) { return hx::Val( paramIntCount ); }
		if (HX_FIELD_EQ(inName,"paramRefs_Int") ) { return hx::Val( paramRefs_Int ); }
		if (HX_FIELD_EQ(inName,"clearOverride") ) { return hx::Val( clearOverride_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"inputMipFilter") ) { return hx::Val( inputMipFilter ); }
		if (HX_FIELD_EQ(inName,"overrideValues") ) { return hx::Val( overrideValues ); }
		if (HX_FIELD_EQ(inName,"paramBoolCount") ) { return hx::Val( paramBoolCount ); }
		if (HX_FIELD_EQ(inName,"paramPositions") ) { return hx::Val( paramPositions ); }
		if (HX_FIELD_EQ(inName,"paramRefs_Bool") ) { return hx::Val( paramRefs_Bool ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"paramDataBuffer") ) { return hx::Val( paramDataBuffer ); }
		if (HX_FIELD_EQ(inName,"paramDataLength") ) { return hx::Val( paramDataLength ); }
		if (HX_FIELD_EQ(inName,"paramFloatCount") ) { return hx::Val( paramFloatCount ); }
		if (HX_FIELD_EQ(inName,"paramRefs_Float") ) { return hx::Val( paramRefs_Float ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val ShaderBuffer_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"inputs") ) { inputs=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::openfl::display::GraphicsShader >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"inputRefs") ) { inputRefs=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"inputWrap") ) { inputWrap=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramData") ) { paramData=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"inputCount") ) { inputCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramCount") ) { paramCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramTypes") ) { paramTypes=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"inputFilter") ) { inputFilter=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"paramLengths") ) { paramLengths=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"overrideCount") ) { overrideCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"overrideNames") ) { overrideNames=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramIntCount") ) { paramIntCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramRefs_Int") ) { paramRefs_Int=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"inputMipFilter") ) { inputMipFilter=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"overrideValues") ) { overrideValues=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramBoolCount") ) { paramBoolCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramPositions") ) { paramPositions=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramRefs_Bool") ) { paramRefs_Bool=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"paramDataBuffer") ) { paramDataBuffer=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramDataLength") ) { paramDataLength=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramFloatCount") ) { paramFloatCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paramRefs_Float") ) { paramRefs_Float=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ShaderBuffer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("inputCount","\x65","\x0c","\x9e","\xc8"));
	outFields->push(HX_HCSTRING("inputRefs","\xea","\x0c","\xd2","\x12"));
	outFields->push(HX_HCSTRING("inputFilter","\x62","\xfb","\x68","\x7a"));
	outFields->push(HX_HCSTRING("inputMipFilter","\x02","\x57","\x6d","\x70"));
	outFields->push(HX_HCSTRING("inputs","\x29","\xc5","\xed","\x9b"));
	outFields->push(HX_HCSTRING("inputWrap","\xf4","\xf6","\x29","\x16"));
	outFields->push(HX_HCSTRING("overrideCount","\xe3","\xbe","\xcc","\xe8"));
	outFields->push(HX_HCSTRING("overrideNames","\xdc","\x09","\xee","\x34"));
	outFields->push(HX_HCSTRING("overrideValues","\x4e","\x5b","\x98","\x4d"));
	outFields->push(HX_HCSTRING("paramBoolCount","\xf8","\x3d","\x05","\xd8"));
	outFields->push(HX_HCSTRING("paramCount","\x02","\x15","\x9d","\xba"));
	outFields->push(HX_HCSTRING("paramData","\x57","\xcd","\xd1","\x32"));
	outFields->push(HX_HCSTRING("paramDataBuffer","\xb7","\x19","\x9e","\x7c"));
	outFields->push(HX_HCSTRING("paramDataLength","\x9d","\xf1","\x10","\x4b"));
	outFields->push(HX_HCSTRING("paramFloatCount","\x80","\xb0","\x63","\x29"));
	outFields->push(HX_HCSTRING("paramIntCount","\x0d","\x77","\x5e","\xea"));
	outFields->push(HX_HCSTRING("paramLengths","\xc0","\x37","\x0f","\xd6"));
	outFields->push(HX_HCSTRING("paramPositions","\x5d","\x59","\x23","\x07"));
	outFields->push(HX_HCSTRING("paramRefs_Bool","\x1c","\xca","\xd6","\x22"));
	outFields->push(HX_HCSTRING("paramRefs_Float","\x6a","\xb3","\xb8","\xa4"));
	outFields->push(HX_HCSTRING("paramRefs_Int","\x3d","\x4b","\x6b","\x76"));
	outFields->push(HX_HCSTRING("paramTypes","\xac","\x40","\x05","\x8b"));
	outFields->push(HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo ShaderBuffer_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,inputCount),HX_HCSTRING("inputCount","\x65","\x0c","\x9e","\xc8")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,inputRefs),HX_HCSTRING("inputRefs","\xea","\x0c","\xd2","\x12")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,inputFilter),HX_HCSTRING("inputFilter","\x62","\xfb","\x68","\x7a")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,inputMipFilter),HX_HCSTRING("inputMipFilter","\x02","\x57","\x6d","\x70")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,inputs),HX_HCSTRING("inputs","\x29","\xc5","\xed","\x9b")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,inputWrap),HX_HCSTRING("inputWrap","\xf4","\xf6","\x29","\x16")},
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,overrideCount),HX_HCSTRING("overrideCount","\xe3","\xbe","\xcc","\xe8")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(ShaderBuffer_obj,overrideNames),HX_HCSTRING("overrideNames","\xdc","\x09","\xee","\x34")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,overrideValues),HX_HCSTRING("overrideValues","\x4e","\x5b","\x98","\x4d")},
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,paramBoolCount),HX_HCSTRING("paramBoolCount","\xf8","\x3d","\x05","\xd8")},
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,paramCount),HX_HCSTRING("paramCount","\x02","\x15","\x9d","\xba")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(ShaderBuffer_obj,paramData),HX_HCSTRING("paramData","\x57","\xcd","\xd1","\x32")},
	{hx::fsObject /*::lime::graphics::opengl::GLObject*/ ,(int)offsetof(ShaderBuffer_obj,paramDataBuffer),HX_HCSTRING("paramDataBuffer","\xb7","\x19","\x9e","\x7c")},
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,paramDataLength),HX_HCSTRING("paramDataLength","\x9d","\xf1","\x10","\x4b")},
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,paramFloatCount),HX_HCSTRING("paramFloatCount","\x80","\xb0","\x63","\x29")},
	{hx::fsInt,(int)offsetof(ShaderBuffer_obj,paramIntCount),HX_HCSTRING("paramIntCount","\x0d","\x77","\x5e","\xea")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(ShaderBuffer_obj,paramLengths),HX_HCSTRING("paramLengths","\xc0","\x37","\x0f","\xd6")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(ShaderBuffer_obj,paramPositions),HX_HCSTRING("paramPositions","\x5d","\x59","\x23","\x07")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,paramRefs_Bool),HX_HCSTRING("paramRefs_Bool","\x1c","\xca","\xd6","\x22")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,paramRefs_Float),HX_HCSTRING("paramRefs_Float","\x6a","\xb3","\xb8","\xa4")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(ShaderBuffer_obj,paramRefs_Int),HX_HCSTRING("paramRefs_Int","\x3d","\x4b","\x6b","\x76")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(ShaderBuffer_obj,paramTypes),HX_HCSTRING("paramTypes","\xac","\x40","\x05","\x8b")},
	{hx::fsObject /*::openfl::display::GraphicsShader*/ ,(int)offsetof(ShaderBuffer_obj,shader),HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *ShaderBuffer_obj_sStaticStorageInfo = 0;
#endif

static ::String ShaderBuffer_obj_sMemberFields[] = {
	HX_HCSTRING("inputCount","\x65","\x0c","\x9e","\xc8"),
	HX_HCSTRING("inputRefs","\xea","\x0c","\xd2","\x12"),
	HX_HCSTRING("inputFilter","\x62","\xfb","\x68","\x7a"),
	HX_HCSTRING("inputMipFilter","\x02","\x57","\x6d","\x70"),
	HX_HCSTRING("inputs","\x29","\xc5","\xed","\x9b"),
	HX_HCSTRING("inputWrap","\xf4","\xf6","\x29","\x16"),
	HX_HCSTRING("overrideCount","\xe3","\xbe","\xcc","\xe8"),
	HX_HCSTRING("overrideNames","\xdc","\x09","\xee","\x34"),
	HX_HCSTRING("overrideValues","\x4e","\x5b","\x98","\x4d"),
	HX_HCSTRING("paramBoolCount","\xf8","\x3d","\x05","\xd8"),
	HX_HCSTRING("paramCount","\x02","\x15","\x9d","\xba"),
	HX_HCSTRING("paramData","\x57","\xcd","\xd1","\x32"),
	HX_HCSTRING("paramDataBuffer","\xb7","\x19","\x9e","\x7c"),
	HX_HCSTRING("paramDataLength","\x9d","\xf1","\x10","\x4b"),
	HX_HCSTRING("paramFloatCount","\x80","\xb0","\x63","\x29"),
	HX_HCSTRING("paramIntCount","\x0d","\x77","\x5e","\xea"),
	HX_HCSTRING("paramLengths","\xc0","\x37","\x0f","\xd6"),
	HX_HCSTRING("paramPositions","\x5d","\x59","\x23","\x07"),
	HX_HCSTRING("paramRefs_Bool","\x1c","\xca","\xd6","\x22"),
	HX_HCSTRING("paramRefs_Float","\x6a","\xb3","\xb8","\xa4"),
	HX_HCSTRING("paramRefs_Int","\x3d","\x4b","\x6b","\x76"),
	HX_HCSTRING("paramTypes","\xac","\x40","\x05","\x8b"),
	HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"),
	HX_HCSTRING("addOverride","\x8d","\x59","\x84","\x7a"),
	HX_HCSTRING("clearOverride","\xf9","\x24","\x85","\x7c"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	::String(null()) };

static void ShaderBuffer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ShaderBuffer_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ShaderBuffer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ShaderBuffer_obj::__mClass,"__mClass");
};

#endif

hx::Class ShaderBuffer_obj::__mClass;

void ShaderBuffer_obj::__register()
{
	hx::Object *dummy = new ShaderBuffer_obj;
	ShaderBuffer_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.ShaderBuffer","\x00","\x7c","\x2e","\xb6");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = ShaderBuffer_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ShaderBuffer_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ShaderBuffer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ShaderBuffer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ShaderBuffer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ShaderBuffer_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
