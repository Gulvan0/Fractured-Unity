// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__backend_native_NativeGLRenderContext
#include <lime/_backend/native/NativeGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLContextType
#include <lime/graphics/opengl/GLContextType.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl__WebGLContext_WebGLContext_Impl_
#include <lime/graphics/opengl/_WebGLContext/WebGLContext_Impl_.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_Log
#include <lime/utils/Log.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_ShaderBuffer
#include <openfl/_internal/renderer/ShaderBuffer.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Bool
#include <openfl/display/ShaderParameter_Bool.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Int
#include <openfl/display/ShaderParameter_Int.h>
#endif
#ifndef INCLUDED_openfl_display__ShaderData_ShaderData_Impl_
#include <openfl/display/_ShaderData/ShaderData_Impl_.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_4b006e5218f2daf8_75_new,"openfl.display.Shader","new",0x88fbb381,"openfl.display.Shader.new","openfl/display/Shader.hx",75,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_87___clearUseArray,"openfl.display.Shader","__clearUseArray",0xbc4a9c00,"openfl.display.Shader.__clearUseArray","openfl/display/Shader.hx",87,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_166___createGLShader,"openfl.display.Shader","__createGLShader",0xd8186585,"openfl.display.Shader.__createGLShader","openfl/display/Shader.hx",166,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_186___createGLProgram,"openfl.display.Shader","__createGLProgram",0xd1b33824,"openfl.display.Shader.__createGLProgram","openfl/display/Shader.hx",186,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_224___disable,"openfl.display.Shader","__disable",0x171f2ca9,"openfl.display.Shader.__disable","openfl/display/Shader.hx",224,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_233___disableGL,"openfl.display.Shader","__disableGL",0x7ec2a70e,"openfl.display.Shader.__disableGL","openfl/display/Shader.hx",233,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_271___enable,"openfl.display.Shader","__enable",0x8f5f3ee2,"openfl.display.Shader.__enable","openfl/display/Shader.hx",271,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_284___enableGL,"openfl.display.Shader","__enableGL",0x94d67987,"openfl.display.Shader.__enableGL","openfl/display/Shader.hx",284,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_308___init,"openfl.display.Shader","__init",0x2faba5af,"openfl.display.Shader.__init","openfl/display/Shader.hx",308,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_325___initGL,"openfl.display.Shader","__initGL",0x2e23ed94,"openfl.display.Shader.__initGL","openfl/display/Shader.hx",325,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_433___processGLData,"openfl.display.Shader","__processGLData",0x90b8a01f,"openfl.display.Shader.__processGLData","openfl/display/Shader.hx",433,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_608___update,"openfl.display.Shader","__update",0x1ddd1668,"openfl.display.Shader.__update","openfl/display/Shader.hx",608,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_619___updateFromBuffer,"openfl.display.Shader","__updateFromBuffer",0x7639ee92,"openfl.display.Shader.__updateFromBuffer","openfl/display/Shader.hx",619,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_628___updateGL,"openfl.display.Shader","__updateGL",0x201dbe8d,"openfl.display.Shader.__updateGL","openfl/display/Shader.hx",628,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_664___updateGLFromBuffer,"openfl.display.Shader","__updateGLFromBuffer",0x5f0216f7,"openfl.display.Shader.__updateGLFromBuffer","openfl/display/Shader.hx",664,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_820_get_data,"openfl.display.Shader","get_data",0xb0c636f2,"openfl.display.Shader.get_data","openfl/display/Shader.hx",820,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_835_set_data,"openfl.display.Shader","set_data",0x5f239066,"openfl.display.Shader.set_data","openfl/display/Shader.hx",835,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_842_get_glFragmentSource,"openfl.display.Shader","get_glFragmentSource",0x5d5fb298,"openfl.display.Shader.get_glFragmentSource","openfl/display/Shader.hx",842,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_847_set_glFragmentSource,"openfl.display.Shader","set_glFragmentSource",0x2a176a0c,"openfl.display.Shader.set_glFragmentSource","openfl/display/Shader.hx",847,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_862_get_glVertexSource,"openfl.display.Shader","get_glVertexSource",0xa3c917ec,"openfl.display.Shader.get_glVertexSource","openfl/display/Shader.hx",862,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_867_set_glVertexSource,"openfl.display.Shader","set_glVertexSource",0x80784a60,"openfl.display.Shader.set_glVertexSource","openfl/display/Shader.hx",867,0xae8f5dcd)
HX_LOCAL_STACK_FRAME(_hx_pos_4b006e5218f2daf8_29_boot,"openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",29,0xae8f5dcd)
namespace openfl{
namespace display{

void Shader_obj::__construct( ::openfl::utils::ByteArrayData code){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_75_new)
HXLINE(  77)		this->byteCode = code;
HXLINE(  78)		this->precisionHint = (int)1;
HXLINE(  80)		this->_hx___glSourceDirty = true;
HXLINE(  81)		this->_hx___numPasses = (int)1;
HXLINE(  82)		this->_hx___data = ::openfl::display::_ShaderData::ShaderData_Impl__obj::_new(code);
            	}

Dynamic Shader_obj::__CreateEmpty() { return new Shader_obj; }

void *Shader_obj::_hx_vtable = 0;

Dynamic Shader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Shader_obj > _hx_result = new Shader_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Shader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x676ab1f7;
}

void Shader_obj::_hx___clearUseArray(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_87___clearUseArray)
HXLINE(  89)		{
HXLINE(  89)			int _g = (int)0;
HXDLIN(  89)			::Array< ::Dynamic> _g1 = this->_hx___paramBool;
HXDLIN(  89)			while((_g < _g1->length)){
HXLINE(  89)				 ::openfl::display::ShaderParameter_Bool parameter = _g1->__get(_g).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXDLIN(  89)				_g = (_g + (int)1);
HXLINE(  91)				parameter->_hx___useArray = false;
            			}
            		}
HXLINE(  95)		{
HXLINE(  95)			int _g2 = (int)0;
HXDLIN(  95)			::Array< ::Dynamic> _g11 = this->_hx___paramFloat;
HXDLIN(  95)			while((_g2 < _g11->length)){
HXLINE(  95)				 ::openfl::display::ShaderParameter_Float parameter1 = _g11->__get(_g2).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXDLIN(  95)				_g2 = (_g2 + (int)1);
HXLINE(  97)				parameter1->_hx___useArray = false;
            			}
            		}
HXLINE( 101)		{
HXLINE( 101)			int _g3 = (int)0;
HXDLIN( 101)			::Array< ::Dynamic> _g12 = this->_hx___paramInt;
HXDLIN( 101)			while((_g3 < _g12->length)){
HXLINE( 101)				 ::openfl::display::ShaderParameter_Int parameter2 = _g12->__get(_g3).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXDLIN( 101)				_g3 = (_g3 + (int)1);
HXLINE( 103)				parameter2->_hx___useArray = false;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___clearUseArray,(void))

 ::lime::graphics::opengl::GLObject Shader_obj::_hx___createGLShader(::String source,int type){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_166___createGLShader)
HXLINE( 168)		 ::lime::graphics::opengl::GLObject shader = this->gl->createShader(type);
HXLINE( 169)		this->gl->shaderSource(shader,source);
HXLINE( 170)		this->gl->compileShader(shader);
HXLINE( 172)		if (hx::IsEq( this->gl->getShaderParameter(shader,this->gl->COMPILE_STATUS),(int)0 )) {
HXLINE( 174)			::String message;
HXDLIN( 174)			if ((type == this->gl->VERTEX_SHADER)) {
HXLINE( 174)				message = HX_("Error compiling vertex shader",39,c9,c1,b2);
            			}
            			else {
HXLINE( 174)				message = HX_("Error compiling fragment shader",4d,d0,be,e3);
            			}
HXLINE( 175)			message = (message + (HX_("\n",0a,00,00,00) + this->gl->getShaderInfoLog(shader)));
HXLINE( 176)			message = (message + (HX_("\n",0a,00,00,00) + source));
HXLINE( 177)			::lime::utils::Log_obj::error(message,hx::SourceInfo(HX_("Shader.hx",99,a8,0b,d1),177,HX_("openfl.display.Shader",0f,df,61,a7),HX_("__createGLShader",46,69,da,33)));
            		}
HXLINE( 181)		return shader;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Shader_obj,_hx___createGLShader,return )

 ::lime::graphics::opengl::GLObject Shader_obj::_hx___createGLProgram(::String vertexSource,::String fragmentSource){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_186___createGLProgram)
HXLINE( 188)		 ::lime::graphics::opengl::GLObject vertexShader = this->_hx___createGLShader(vertexSource,this->gl->VERTEX_SHADER);
HXLINE( 189)		 ::lime::graphics::opengl::GLObject fragmentShader = this->_hx___createGLShader(fragmentSource,this->gl->FRAGMENT_SHADER);
HXLINE( 191)		 ::lime::graphics::opengl::GLObject program = this->gl->createProgram();
HXLINE( 194)		{
HXLINE( 194)			int _g = (int)0;
HXDLIN( 194)			::Array< ::Dynamic> _g1 = this->_hx___paramFloat;
HXDLIN( 194)			while((_g < _g1->length)){
HXLINE( 194)				 ::openfl::display::ShaderParameter_Float param = _g1->__get(_g).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXDLIN( 194)				_g = (_g + (int)1);
HXLINE( 196)				bool _hx_tmp;
HXDLIN( 196)				if ((param->name.indexOf(HX_("Position",c9,5c,ac,a4),null()) > (int)-1)) {
HXLINE( 196)					_hx_tmp = ::StringTools_obj::startsWith(param->name,HX_("openfl_",cf,ba,42,40));
            				}
            				else {
HXLINE( 196)					_hx_tmp = false;
            				}
HXDLIN( 196)				if (_hx_tmp) {
HXLINE( 198)					this->gl->bindAttribLocation(program,(int)0,param->name);
HXLINE( 199)					goto _hx_goto_6;
            				}
            			}
            			_hx_goto_6:;
            		}
HXLINE( 205)		this->gl->attachShader(program,vertexShader);
HXLINE( 206)		this->gl->attachShader(program,fragmentShader);
HXLINE( 207)		this->gl->linkProgram(program);
HXLINE( 209)		if (hx::IsEq( this->gl->getProgramParameter(program,this->gl->LINK_STATUS),(int)0 )) {
HXLINE( 211)			::String message = HX_("Unable to initialize the shader program",f0,86,8b,39);
HXLINE( 212)			message = (message + (HX_("\n",0a,00,00,00) + this->gl->getProgramInfoLog(program)));
HXLINE( 213)			::lime::utils::Log_obj::error(message,hx::SourceInfo(HX_("Shader.hx",99,a8,0b,d1),213,HX_("openfl.display.Shader",0f,df,61,a7),HX_("__createGLProgram",43,7d,b4,bf)));
            		}
HXLINE( 217)		return program;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Shader_obj,_hx___createGLProgram,return )

void Shader_obj::_hx___disable(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_224___disable)
HXDLIN( 224)		if (hx::IsNotNull( this->glProgram )) {
HXLINE( 226)			this->_hx___disableGL();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___disable,(void))

void Shader_obj::_hx___disableGL(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_233___disableGL)
HXLINE( 241)		{
HXLINE( 241)			int _g = (int)0;
HXDLIN( 241)			::Array< ::Dynamic> _g1 = this->_hx___paramBool;
HXDLIN( 241)			while((_g < _g1->length)){
HXLINE( 241)				 ::openfl::display::ShaderParameter_Bool parameter = _g1->__get(_g).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXDLIN( 241)				_g = (_g + (int)1);
HXLINE( 243)				parameter->_hx___disableGL(this->gl);
            			}
            		}
HXLINE( 247)		{
HXLINE( 247)			int _g2 = (int)0;
HXDLIN( 247)			::Array< ::Dynamic> _g11 = this->_hx___paramFloat;
HXDLIN( 247)			while((_g2 < _g11->length)){
HXLINE( 247)				 ::openfl::display::ShaderParameter_Float parameter1 = _g11->__get(_g2).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXDLIN( 247)				_g2 = (_g2 + (int)1);
HXLINE( 249)				parameter1->_hx___disableGL(this->gl);
            			}
            		}
HXLINE( 253)		{
HXLINE( 253)			int _g3 = (int)0;
HXDLIN( 253)			::Array< ::Dynamic> _g12 = this->_hx___paramInt;
HXDLIN( 253)			while((_g3 < _g12->length)){
HXLINE( 253)				 ::openfl::display::ShaderParameter_Int parameter2 = _g12->__get(_g3).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXDLIN( 253)				_g3 = (_g3 + (int)1);
HXLINE( 255)				parameter2->_hx___disableGL(this->gl);
            			}
            		}
HXLINE( 259)		this->gl->bindBuffer(this->gl->ARRAY_BUFFER,null());
HXLINE( 260)		this->gl->bindTexture(this->gl->TEXTURE_2D,null());
HXLINE( 262)		if (hx::IsEq( this->gl->type,::lime::graphics::opengl::GLContextType_obj::OPENGL_dyn() )) {
HXLINE( 264)			this->gl->disable(this->gl->TEXTURE_2D);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___disableGL,(void))

void Shader_obj::_hx___enable(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_271___enable)
HXLINE( 273)		this->_hx___init();
HXLINE( 275)		if (hx::IsNotNull( this->glProgram )) {
HXLINE( 277)			this->_hx___enableGL();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___enable,(void))

void Shader_obj::_hx___enableGL(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_284___enableGL)
HXLINE( 286)		int textureCount = (int)0;
HXLINE( 288)		{
HXLINE( 288)			int _g = (int)0;
HXDLIN( 288)			::Array< ::Dynamic> _g1 = this->_hx___inputBitmapData;
HXDLIN( 288)			while((_g < _g1->length)){
HXLINE( 288)				 ::openfl::display::ShaderInput_openfl_display_BitmapData input = _g1->__get(_g).StaticCast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >();
HXDLIN( 288)				_g = (_g + (int)1);
HXLINE( 292)				this->gl->uniform1i(input->index,textureCount);
HXLINE( 293)				textureCount = (textureCount + (int)1);
            			}
            		}
HXLINE( 299)		bool _hx_tmp;
HXDLIN( 299)		if (hx::IsEq( this->gl->type,::lime::graphics::opengl::GLContextType_obj::OPENGL_dyn() )) {
HXLINE( 299)			_hx_tmp = (textureCount > (int)0);
            		}
            		else {
HXLINE( 299)			_hx_tmp = false;
            		}
HXDLIN( 299)		if (_hx_tmp) {
HXLINE( 301)			this->gl->enable(this->gl->TEXTURE_2D);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___enableGL,(void))

void Shader_obj::_hx___init(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_308___init)
HXLINE( 310)		if (hx::IsNull( this->_hx___data )) {
HXLINE( 312)			this->_hx___data = ::openfl::display::_ShaderData::ShaderData_Impl__obj::_new(null());
            		}
HXLINE( 316)		bool _hx_tmp;
HXDLIN( 316)		bool _hx_tmp1;
HXDLIN( 316)		if (hx::IsNotNull( this->_hx___glFragmentSource )) {
HXLINE( 316)			_hx_tmp1 = hx::IsNotNull( this->_hx___glVertexSource );
            		}
            		else {
HXLINE( 316)			_hx_tmp1 = false;
            		}
HXDLIN( 316)		if (_hx_tmp1) {
HXLINE( 316)			if (hx::IsNotNull( this->glProgram )) {
HXLINE( 316)				_hx_tmp = this->_hx___glSourceDirty;
            			}
            			else {
HXLINE( 316)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 316)			_hx_tmp = false;
            		}
HXDLIN( 316)		if (_hx_tmp) {
HXLINE( 318)			this->_hx___initGL();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___init,(void))

void Shader_obj::_hx___initGL(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_325___initGL)
HXLINE( 327)		bool _hx_tmp;
HXDLIN( 327)		if (!(this->_hx___glSourceDirty)) {
HXLINE( 327)			_hx_tmp = hx::IsNull( this->_hx___paramBool );
            		}
            		else {
HXLINE( 327)			_hx_tmp = true;
            		}
HXDLIN( 327)		if (_hx_tmp) {
HXLINE( 329)			this->_hx___glSourceDirty = false;
HXLINE( 330)			this->glProgram = null();
HXLINE( 332)			this->_hx___inputBitmapData = ::Array_obj< ::Dynamic>::__new();
HXLINE( 333)			this->_hx___paramBool = ::Array_obj< ::Dynamic>::__new();
HXLINE( 334)			this->_hx___paramFloat = ::Array_obj< ::Dynamic>::__new();
HXLINE( 335)			this->_hx___paramInt = ::Array_obj< ::Dynamic>::__new();
HXLINE( 337)			this->_hx___processGLData(this->get_glVertexSource(),HX_("attribute",1c,70,f0,fa));
HXLINE( 338)			this->_hx___processGLData(this->get_glVertexSource(),HX_("uniform",34,41,64,b5));
HXLINE( 339)			this->_hx___processGLData(this->get_glFragmentSource(),HX_("uniform",34,41,64,b5));
            		}
HXLINE( 343)		bool _hx_tmp1;
HXDLIN( 343)		if (hx::IsNotNull( this->gl )) {
HXLINE( 343)			_hx_tmp1 = hx::IsNull( this->glProgram );
            		}
            		else {
HXLINE( 343)			_hx_tmp1 = false;
            		}
HXDLIN( 343)		if (_hx_tmp1) {
HXLINE( 348)			::String prefix;
HXDLIN( 348)			if (hx::IsEq( this->precisionHint,(int)1 )) {
HXLINE( 348)				prefix = HX_("mediump",5b,92,81,f0);
            			}
            			else {
HXLINE( 348)				prefix = HX_("lowp",5c,ad,b7,47);
            			}
HXLINE( 345)			::String prefix1 = ((HX_("#ifdef GL_ES\n\t\t\t\tprecision ",df,92,6a,64) + prefix) + HX_(" float;\n\t\t\t\t#endif\n\t\t\t\t",ea,d3,26,bb));
HXLINE( 352)			::String vertex = (prefix1 + this->get_glVertexSource());
HXLINE( 353)			::String fragment = (prefix1 + this->get_glFragmentSource());
HXLINE( 355)			::String id = (vertex + fragment);
HXLINE( 357)			if (::openfl::display::Shader_obj::_hx___glPrograms->exists(id)) {
HXLINE( 359)				this->glProgram = ::openfl::display::Shader_obj::_hx___glPrograms->get(id).StaticCast<  ::lime::graphics::opengl::GLObject >();
            			}
            			else {
HXLINE( 363)				this->glProgram = this->_hx___createGLProgram(vertex,fragment);
HXLINE( 364)				::openfl::display::Shader_obj::_hx___glPrograms->set(id,this->glProgram);
            			}
HXLINE( 368)			if (hx::IsNotNull( this->glProgram )) {
HXLINE( 370)				{
HXLINE( 370)					int _g = (int)0;
HXDLIN( 370)					::Array< ::Dynamic> _g1 = this->_hx___inputBitmapData;
HXDLIN( 370)					while((_g < _g1->length)){
HXLINE( 370)						 ::openfl::display::ShaderInput_openfl_display_BitmapData input = _g1->__get(_g).StaticCast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >();
HXDLIN( 370)						_g = (_g + (int)1);
HXLINE( 372)						if (input->_hx___isUniform) {
HXLINE( 374)							input->index = this->gl->getUniformLocation(this->glProgram,input->name);
            						}
            						else {
HXLINE( 378)							input->index = this->gl->getAttribLocation(this->glProgram,input->name);
            						}
            					}
            				}
HXLINE( 384)				{
HXLINE( 384)					int _g2 = (int)0;
HXDLIN( 384)					::Array< ::Dynamic> _g11 = this->_hx___paramBool;
HXDLIN( 384)					while((_g2 < _g11->length)){
HXLINE( 384)						 ::openfl::display::ShaderParameter_Bool parameter = _g11->__get(_g2).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXDLIN( 384)						_g2 = (_g2 + (int)1);
HXLINE( 386)						if (parameter->_hx___isUniform) {
HXLINE( 388)							parameter->index = this->gl->getUniformLocation(this->glProgram,parameter->name);
            						}
            						else {
HXLINE( 392)							parameter->index = this->gl->getAttribLocation(this->glProgram,parameter->name);
            						}
            					}
            				}
HXLINE( 398)				{
HXLINE( 398)					int _g3 = (int)0;
HXDLIN( 398)					::Array< ::Dynamic> _g12 = this->_hx___paramFloat;
HXDLIN( 398)					while((_g3 < _g12->length)){
HXLINE( 398)						 ::openfl::display::ShaderParameter_Float parameter1 = _g12->__get(_g3).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXDLIN( 398)						_g3 = (_g3 + (int)1);
HXLINE( 400)						if (parameter1->_hx___isUniform) {
HXLINE( 402)							parameter1->index = this->gl->getUniformLocation(this->glProgram,parameter1->name);
            						}
            						else {
HXLINE( 406)							parameter1->index = this->gl->getAttribLocation(this->glProgram,parameter1->name);
            						}
            					}
            				}
HXLINE( 412)				{
HXLINE( 412)					int _g4 = (int)0;
HXDLIN( 412)					::Array< ::Dynamic> _g13 = this->_hx___paramInt;
HXDLIN( 412)					while((_g4 < _g13->length)){
HXLINE( 412)						 ::openfl::display::ShaderParameter_Int parameter2 = _g13->__get(_g4).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXDLIN( 412)						_g4 = (_g4 + (int)1);
HXLINE( 414)						if (parameter2->_hx___isUniform) {
HXLINE( 416)							parameter2->index = this->gl->getUniformLocation(this->glProgram,parameter2->name);
            						}
            						else {
HXLINE( 420)							parameter2->index = this->gl->getAttribLocation(this->glProgram,parameter2->name);
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___initGL,(void))

void Shader_obj::_hx___processGLData(::String source,::String storageType){
            	HX_GC_STACKFRAME(&_hx_pos_4b006e5218f2daf8_433___processGLData)
HXLINE( 435)		int lastMatch = (int)0;
HXDLIN( 435)		 ::Dynamic position;
HXDLIN( 435)		 ::EReg regex;
HXDLIN( 435)		::String name;
HXDLIN( 435)		::String type;
HXLINE( 437)		if ((storageType == HX_("uniform",34,41,64,b5))) {
HXLINE( 439)			regex =  ::EReg_obj::__alloc( HX_CTX ,HX_("uniform ([A-Za-z0-9]+) ([A-Za-z0-9_]+)",e3,a8,c0,f8),HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 443)			regex =  ::EReg_obj::__alloc( HX_CTX ,HX_("attribute ([A-Za-z0-9]+) ([A-Za-z0-9_]+)",fb,2e,25,cc),HX_("",00,00,00,00));
            		}
HXLINE( 447)		while(regex->matchSub(source,lastMatch,null())){
HXLINE( 449)			type = regex->matched((int)1);
HXLINE( 450)			name = regex->matched((int)2);
HXLINE( 452)			if (::StringTools_obj::startsWith(name,HX_("gl_",9a,86,4e,00))) {
HXLINE( 454)				continue;
            			}
HXLINE( 458)			bool isUniform = (storageType == HX_("uniform",34,41,64,b5));
HXLINE( 460)			if (::StringTools_obj::startsWith(type,HX_("sampler",08,c5,c9,83))) {
HXLINE( 462)				 ::openfl::display::ShaderInput_openfl_display_BitmapData input =  ::openfl::display::ShaderInput_openfl_display_BitmapData_obj::__alloc( HX_CTX );
HXLINE( 463)				input->name = name;
HXLINE( 464)				input->_hx___isUniform = isUniform;
HXLINE( 465)				this->_hx___inputBitmapData->push(input);
HXLINE( 467)				::String _hx_switch_0 = name;
            				if (  (_hx_switch_0==HX_("bitmap",ef,0f,0c,f1)) ){
HXLINE( 470)					this->_hx___bitmap = input;
HXDLIN( 470)					goto _hx_goto_23;
            				}
            				if (  (_hx_switch_0==HX_("openfl_Texture",cc,bd,e4,7e)) ){
HXLINE( 469)					this->_hx___texture = input;
HXDLIN( 469)					goto _hx_goto_23;
            				}
            				/* default */{
            				}
            				_hx_goto_23:;
HXLINE( 475)				::Reflect_obj::setField(this->_hx___data,name,input);
HXLINE( 476)				if (this->_hx___isGenerated) {
HXLINE( 476)					::Reflect_obj::setField(hx::ObjectPtr<OBJ_>(this),name,input);
            				}
            			}
            			else {
HXLINE( 478)				bool _hx_tmp;
HXDLIN( 478)				if (!(!(::Reflect_obj::hasField(this->_hx___data,name)))) {
HXLINE( 478)					_hx_tmp = hx::IsNull( ::Reflect_obj::field(this->_hx___data,name) );
            				}
            				else {
HXLINE( 478)					_hx_tmp = true;
            				}
HXDLIN( 478)				if (_hx_tmp) {
HXLINE( 480)					 ::Dynamic parameterType;
HXDLIN( 480)					::String _hx_switch_1 = type;
            					if (  (_hx_switch_1==HX_("bool",2a,84,1b,41)) ){
HXLINE( 480)						parameterType = (int)0;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("bvec2",c0,00,91,bb)) ){
HXLINE( 480)						parameterType = (int)1;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("bvec3",c1,00,91,bb)) ){
HXLINE( 480)						parameterType = (int)2;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("bvec4",c2,00,91,bb)) ){
HXLINE( 480)						parameterType = (int)3;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("dvec2",c2,29,5e,e2)) ||  (_hx_switch_1==HX_("vec2",5e,27,4c,4e)) ){
HXLINE( 480)						parameterType = (int)5;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("dvec3",c3,29,5e,e2)) ||  (_hx_switch_1==HX_("vec3",5f,27,4c,4e)) ){
HXLINE( 480)						parameterType = (int)6;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("double",11,2b,cb,32)) ||  (_hx_switch_1==HX_("float",9c,c5,96,02)) ){
HXLINE( 480)						parameterType = (int)4;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("ivec3",48,10,5f,c3)) ||  (_hx_switch_1==HX_("uvec3",54,06,2e,ac)) ){
HXLINE( 480)						parameterType = (int)10;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("ivec4",49,10,5f,c3)) ||  (_hx_switch_1==HX_("uvec4",55,06,2e,ac)) ){
HXLINE( 480)						parameterType = (int)11;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat2",92,41,56,48)) ||  (_hx_switch_1==HX_("mat2x2",cc,b2,97,bb)) ){
HXLINE( 480)						parameterType = (int)12;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat2x3",cd,b2,97,bb)) ){
HXLINE( 480)						parameterType = (int)13;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat2x4",ce,b2,97,bb)) ){
HXLINE( 480)						parameterType = (int)14;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat3x2",0d,75,98,bb)) ){
HXLINE( 480)						parameterType = (int)15;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat3",93,41,56,48)) ||  (_hx_switch_1==HX_("mat3x3",0e,75,98,bb)) ){
HXLINE( 480)						parameterType = (int)16;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat3x4",0f,75,98,bb)) ){
HXLINE( 480)						parameterType = (int)17;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat4",94,41,56,48)) ||  (_hx_switch_1==HX_("mat4x4",50,37,99,bb)) ){
HXLINE( 480)						parameterType = (int)20;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat4x2",4e,37,99,bb)) ){
HXLINE( 480)						parameterType = (int)18;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("mat4x3",4f,37,99,bb)) ){
HXLINE( 480)						parameterType = (int)19;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("int",ef,0c,50,00)) ||  (_hx_switch_1==HX_("uint",9a,03,a6,4d)) ){
HXLINE( 480)						parameterType = (int)8;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("ivec2",47,10,5f,c3)) ||  (_hx_switch_1==HX_("uvec2",53,06,2e,ac)) ){
HXLINE( 480)						parameterType = (int)9;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_1==HX_("dvec4",c4,29,5e,e2)) ||  (_hx_switch_1==HX_("vec4",60,27,4c,4e)) ){
HXLINE( 480)						parameterType = (int)7;
HXDLIN( 480)						goto _hx_goto_24;
            					}
            					/* default */{
HXLINE( 480)						parameterType = null();
            					}
            					_hx_goto_24:;
HXLINE( 507)					int length;
HXDLIN( 507)					 ::Dynamic _hx_switch_2 = parameterType;
            					if (  (_hx_switch_2==(int)1) ||  (_hx_switch_2==(int)5) ||  (_hx_switch_2==(int)9) ){
HXLINE( 507)						length = (int)2;
HXDLIN( 507)						goto _hx_goto_25;
            					}
            					if (  (_hx_switch_2==(int)3) ||  (_hx_switch_2==(int)7) ||  (_hx_switch_2==(int)11) ||  (_hx_switch_2==(int)12) ){
HXLINE( 507)						length = (int)4;
HXDLIN( 507)						goto _hx_goto_25;
            					}
            					if (  (_hx_switch_2==(int)2) ||  (_hx_switch_2==(int)6) ||  (_hx_switch_2==(int)10) ){
HXLINE( 507)						length = (int)3;
HXDLIN( 507)						goto _hx_goto_25;
            					}
            					if (  (_hx_switch_2==(int)16) ){
HXLINE( 507)						length = (int)9;
HXDLIN( 507)						goto _hx_goto_25;
            					}
            					if (  (_hx_switch_2==(int)20) ){
HXLINE( 507)						length = (int)16;
HXDLIN( 507)						goto _hx_goto_25;
            					}
            					/* default */{
HXLINE( 507)						length = (int)1;
            					}
            					_hx_goto_25:;
HXLINE( 518)					int arrayLength;
HXDLIN( 518)					 ::Dynamic _hx_switch_3 = parameterType;
            					if (  (_hx_switch_3==(int)12) ){
HXLINE( 518)						arrayLength = (int)2;
HXDLIN( 518)						goto _hx_goto_26;
            					}
            					if (  (_hx_switch_3==(int)16) ){
HXLINE( 518)						arrayLength = (int)3;
HXDLIN( 518)						goto _hx_goto_26;
            					}
            					if (  (_hx_switch_3==(int)20) ){
HXLINE( 518)						arrayLength = (int)4;
HXDLIN( 518)						goto _hx_goto_26;
            					}
            					/* default */{
HXLINE( 518)						arrayLength = (int)1;
            					}
            					_hx_goto_26:;
HXLINE( 527)					 ::Dynamic _hx_switch_4 = parameterType;
            					if (  (_hx_switch_4==(int)0) ||  (_hx_switch_4==(int)1) ||  (_hx_switch_4==(int)2) ||  (_hx_switch_4==(int)3) ){
HXLINE( 531)						 ::openfl::display::ShaderParameter_Bool parameter =  ::openfl::display::ShaderParameter_Bool_obj::__alloc( HX_CTX );
HXLINE( 532)						parameter->name = name;
HXLINE( 533)						parameter->type = parameterType;
HXLINE( 534)						parameter->_hx___arrayLength = arrayLength;
HXLINE( 535)						parameter->_hx___isBool = true;
HXLINE( 536)						parameter->_hx___isUniform = isUniform;
HXLINE( 537)						parameter->__length = length;
HXLINE( 538)						this->_hx___paramBool->push(parameter);
HXLINE( 540)						if ((name == HX_("openfl_HasColorTransform",b4,00,4b,62))) {
HXLINE( 542)							this->_hx___hasColorTransform = parameter;
            						}
HXLINE( 546)						::Reflect_obj::setField(this->_hx___data,name,parameter);
HXLINE( 547)						if (this->_hx___isGenerated) {
HXLINE( 547)							::Reflect_obj::setField(hx::ObjectPtr<OBJ_>(this),name,parameter);
            						}
HXLINE( 529)						goto _hx_goto_28;
            					}
            					if (  (_hx_switch_4==(int)8) ||  (_hx_switch_4==(int)9) ||  (_hx_switch_4==(int)10) ||  (_hx_switch_4==(int)11) ){
HXLINE( 551)						 ::openfl::display::ShaderParameter_Int parameter1 =  ::openfl::display::ShaderParameter_Int_obj::__alloc( HX_CTX );
HXLINE( 552)						parameter1->name = name;
HXLINE( 553)						parameter1->type = parameterType;
HXLINE( 554)						parameter1->_hx___arrayLength = arrayLength;
HXLINE( 555)						parameter1->_hx___isInt = true;
HXLINE( 556)						parameter1->_hx___isUniform = isUniform;
HXLINE( 557)						parameter1->__length = length;
HXLINE( 558)						this->_hx___paramInt->push(parameter1);
HXLINE( 559)						::Reflect_obj::setField(this->_hx___data,name,parameter1);
HXLINE( 560)						if (this->_hx___isGenerated) {
HXLINE( 560)							::Reflect_obj::setField(hx::ObjectPtr<OBJ_>(this),name,parameter1);
            						}
HXLINE( 549)						goto _hx_goto_28;
            					}
            					/* default */{
HXLINE( 564)						 ::openfl::display::ShaderParameter_Float parameter2 =  ::openfl::display::ShaderParameter_Float_obj::__alloc( HX_CTX );
HXLINE( 565)						parameter2->name = name;
HXLINE( 566)						parameter2->type = parameterType;
HXLINE( 567)						parameter2->_hx___arrayLength = arrayLength;
HXLINE( 568)						if ((arrayLength > (int)0)) {
HXLINE( 568)							 ::Dynamic elements = (arrayLength * arrayLength);
HXDLIN( 568)							 ::lime::utils::ArrayBufferView this1;
HXDLIN( 568)							if (hx::IsNotNull( elements )) {
HXLINE( 568)								this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,(int)8);
            							}
            							else {
HXLINE( 568)								HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            							}
HXDLIN( 568)							parameter2->_hx___uniformMatrix = this1;
            						}
HXLINE( 569)						parameter2->_hx___isFloat = true;
HXLINE( 570)						parameter2->_hx___isUniform = isUniform;
HXLINE( 571)						parameter2->__length = length;
HXLINE( 572)						this->_hx___paramFloat->push(parameter2);
HXLINE( 574)						if (::StringTools_obj::startsWith(name,HX_("openfl_",cf,ba,42,40))) {
HXLINE( 576)							::String _hx_switch_5 = name;
            							if (  (_hx_switch_5==HX_("openfl_Alpha",0f,ce,3e,6a)) ){
HXLINE( 578)								this->_hx___alpha = parameter2;
HXDLIN( 578)								goto _hx_goto_27;
            							}
            							if (  (_hx_switch_5==HX_("openfl_ColorMultiplier",b5,e4,dc,18)) ){
HXLINE( 579)								this->_hx___colorMultiplier = parameter2;
HXDLIN( 579)								goto _hx_goto_27;
            							}
            							if (  (_hx_switch_5==HX_("openfl_ColorOffset",c7,ea,07,41)) ){
HXLINE( 580)								this->_hx___colorOffset = parameter2;
HXDLIN( 580)								goto _hx_goto_27;
            							}
            							if (  (_hx_switch_5==HX_("openfl_Matrix",70,ea,41,06)) ){
HXLINE( 581)								this->_hx___matrix = parameter2;
HXDLIN( 581)								goto _hx_goto_27;
            							}
            							if (  (_hx_switch_5==HX_("openfl_Position",98,fe,6c,ee)) ){
HXLINE( 582)								this->_hx___position = parameter2;
HXDLIN( 582)								goto _hx_goto_27;
            							}
            							if (  (_hx_switch_5==HX_("openfl_TextureCoord",49,e9,27,e8)) ){
HXLINE( 583)								this->_hx___textureCoord = parameter2;
HXDLIN( 583)								goto _hx_goto_27;
            							}
            							if (  (_hx_switch_5==HX_("openfl_TextureSize",ad,60,72,29)) ){
HXLINE( 584)								this->_hx___textureSize = parameter2;
HXDLIN( 584)								goto _hx_goto_27;
            							}
            							/* default */{
            							}
            							_hx_goto_27:;
            						}
HXLINE( 591)						::Reflect_obj::setField(this->_hx___data,name,parameter2);
HXLINE( 592)						if (this->_hx___isGenerated) {
HXLINE( 592)							::Reflect_obj::setField(hx::ObjectPtr<OBJ_>(this),name,parameter2);
            						}
            					}
            					_hx_goto_28:;
            				}
            			}
HXLINE( 598)			position = regex->matchedPos();
HXLINE( 599)			lastMatch = (( (int)(position->__Field(HX_("pos",94,5d,55,00),hx::paccDynamic)) ) + ( (int)(position->__Field(HX_("len",d5,4b,52,00),hx::paccDynamic)) ));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Shader_obj,_hx___processGLData,(void))

void Shader_obj::_hx___update(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_608___update)
HXDLIN( 608)		if (hx::IsNotNull( this->glProgram )) {
HXLINE( 610)			this->_hx___updateGL();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___update,(void))

void Shader_obj::_hx___updateFromBuffer( ::openfl::_internal::renderer::ShaderBuffer shaderBuffer){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_619___updateFromBuffer)
HXDLIN( 619)		if (hx::IsNotNull( this->glProgram )) {
HXLINE( 621)			this->_hx___updateGLFromBuffer(shaderBuffer);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,_hx___updateFromBuffer,(void))

void Shader_obj::_hx___updateGL(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_628___updateGL)
HXLINE( 630)		int textureCount = (int)0;
HXLINE( 632)		{
HXLINE( 632)			int _g = (int)0;
HXDLIN( 632)			::Array< ::Dynamic> _g1 = this->_hx___inputBitmapData;
HXDLIN( 632)			while((_g < _g1->length)){
HXLINE( 632)				 ::openfl::display::ShaderInput_openfl_display_BitmapData input = _g1->__get(_g).StaticCast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >();
HXDLIN( 632)				_g = (_g + (int)1);
HXLINE( 636)				input->_hx___updateGL(this->gl,textureCount,null(),null(),null(),null());
HXLINE( 637)				textureCount = (textureCount + (int)1);
            			}
            		}
HXLINE( 643)		{
HXLINE( 643)			int _g2 = (int)0;
HXDLIN( 643)			::Array< ::Dynamic> _g11 = this->_hx___paramBool;
HXDLIN( 643)			while((_g2 < _g11->length)){
HXLINE( 643)				 ::openfl::display::ShaderParameter_Bool parameter = _g11->__get(_g2).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXDLIN( 643)				_g2 = (_g2 + (int)1);
HXLINE( 645)				parameter->_hx___updateGL(this->gl,null());
            			}
            		}
HXLINE( 649)		{
HXLINE( 649)			int _g3 = (int)0;
HXDLIN( 649)			::Array< ::Dynamic> _g12 = this->_hx___paramFloat;
HXDLIN( 649)			while((_g3 < _g12->length)){
HXLINE( 649)				 ::openfl::display::ShaderParameter_Float parameter1 = _g12->__get(_g3).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXDLIN( 649)				_g3 = (_g3 + (int)1);
HXLINE( 651)				parameter1->_hx___updateGL(this->gl,null());
            			}
            		}
HXLINE( 655)		{
HXLINE( 655)			int _g4 = (int)0;
HXDLIN( 655)			::Array< ::Dynamic> _g13 = this->_hx___paramInt;
HXDLIN( 655)			while((_g4 < _g13->length)){
HXLINE( 655)				 ::openfl::display::ShaderParameter_Int parameter2 = _g13->__get(_g4).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXDLIN( 655)				_g4 = (_g4 + (int)1);
HXLINE( 657)				parameter2->_hx___updateGL(this->gl,null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,_hx___updateGL,(void))

void Shader_obj::_hx___updateGLFromBuffer( ::openfl::_internal::renderer::ShaderBuffer shaderBuffer){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_664___updateGLFromBuffer)
HXLINE( 666)		int textureCount = (int)0;
HXLINE( 667)		 ::openfl::display::ShaderInput_openfl_display_BitmapData input;
HXDLIN( 667)		 ::openfl::display::BitmapData inputData;
HXDLIN( 667)		 ::Dynamic inputFilter;
HXDLIN( 667)		 ::Dynamic inputMipFilter;
HXDLIN( 667)		 ::Dynamic inputWrap;
HXLINE( 669)		{
HXLINE( 669)			int _g1 = (int)0;
HXDLIN( 669)			int _g = shaderBuffer->inputCount;
HXDLIN( 669)			while((_g1 < _g)){
HXLINE( 669)				_g1 = (_g1 + (int)1);
HXDLIN( 669)				int i = (_g1 - (int)1);
HXLINE( 671)				input = shaderBuffer->inputRefs->__get(i).StaticCast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >();
HXLINE( 672)				inputData = shaderBuffer->inputs->__get(i).StaticCast<  ::openfl::display::BitmapData >();
HXLINE( 673)				inputFilter = shaderBuffer->inputFilter->__get(i);
HXLINE( 674)				inputMipFilter = shaderBuffer->inputMipFilter->__get(i);
HXLINE( 675)				inputWrap = shaderBuffer->inputWrap->__get(i);
HXLINE( 677)				if (hx::IsNotNull( inputData )) {
HXLINE( 679)					input->_hx___updateGL(this->gl,textureCount,inputData,inputFilter,inputMipFilter,inputWrap);
HXLINE( 680)					textureCount = (textureCount + (int)1);
            				}
            			}
            		}
HXLINE( 686)		if ((shaderBuffer->paramDataLength > (int)0)) {
HXLINE( 688)			if (hx::IsNull( shaderBuffer->paramDataBuffer )) {
HXLINE( 690)				shaderBuffer->paramDataBuffer = this->gl->createBuffer();
            			}
HXLINE( 696)			this->gl->bindBuffer(this->gl->ARRAY_BUFFER,shaderBuffer->paramDataBuffer);
HXLINE( 697)			::lime::graphics::opengl::_WebGLContext::WebGLContext_Impl__obj::bufferData(this->gl,this->gl->ARRAY_BUFFER,shaderBuffer->paramData,this->gl->DYNAMIC_DRAW);
            		}
            		else {
HXLINE( 703)			this->gl->bindBuffer(this->gl->ARRAY_BUFFER,null());
            		}
HXLINE( 707)		int boolIndex = (int)0;
HXLINE( 708)		int floatIndex = (int)0;
HXLINE( 709)		int intIndex = (int)0;
HXLINE( 711)		int boolCount = shaderBuffer->paramBoolCount;
HXLINE( 712)		int floatCount = shaderBuffer->paramFloatCount;
HXLINE( 713)		 ::lime::utils::ArrayBufferView paramData = shaderBuffer->paramData;
HXLINE( 715)		 ::openfl::display::ShaderParameter_Bool boolRef;
HXDLIN( 715)		 ::openfl::display::ShaderParameter_Float floatRef;
HXDLIN( 715)		 ::openfl::display::ShaderParameter_Int intRef;
HXDLIN( 715)		bool hasOverride;
HXLINE( 716)		::Array< bool > overrideBoolValue = null();
HXDLIN( 716)		::Array< Float > overrideFloatValue = null();
HXDLIN( 716)		::Array< int > overrideIntValue = null();
HXLINE( 718)		{
HXLINE( 718)			int _g11 = (int)0;
HXDLIN( 718)			int _g2 = shaderBuffer->paramCount;
HXDLIN( 718)			while((_g11 < _g2)){
HXLINE( 718)				_g11 = (_g11 + (int)1);
HXDLIN( 718)				int i1 = (_g11 - (int)1);
HXLINE( 720)				hasOverride = false;
HXLINE( 722)				if ((i1 < boolCount)) {
HXLINE( 724)					boolRef = shaderBuffer->paramRefs_Bool->__get(boolIndex).StaticCast<  ::openfl::display::ShaderParameter_Bool >();
HXLINE( 726)					{
HXLINE( 726)						int _g3 = (int)0;
HXDLIN( 726)						int _g21 = shaderBuffer->overrideCount;
HXDLIN( 726)						while((_g3 < _g21)){
HXLINE( 726)							_g3 = (_g3 + (int)1);
HXDLIN( 726)							int j = (_g3 - (int)1);
HXLINE( 728)							::String boolRef1 = boolRef->name;
HXDLIN( 728)							if ((boolRef1 == shaderBuffer->overrideNames->__get(j))) {
HXLINE( 730)								overrideBoolValue = ::cpp::VirtualArray( shaderBuffer->overrideValues->__get(j));
HXLINE( 731)								hasOverride = true;
HXLINE( 732)								goto _hx_goto_39;
            							}
            						}
            						_hx_goto_39:;
            					}
HXLINE( 738)					if (hasOverride) {
HXLINE( 740)						boolRef->_hx___updateGL(this->gl,overrideBoolValue);
            					}
            					else {
HXLINE( 744)						 ::lime::_backend::native::NativeGLRenderContext _hx_tmp = this->gl;
HXDLIN( 744)						int shaderBuffer1 = shaderBuffer->paramPositions->__get(i1);
HXDLIN( 744)						boolRef->_hx___updateGLFromBuffer(_hx_tmp,paramData,shaderBuffer1,shaderBuffer->paramLengths->__get(i1));
            					}
HXLINE( 748)					boolIndex = (boolIndex + (int)1);
            				}
            				else {
HXLINE( 750)					if ((i1 < (boolCount + floatCount))) {
HXLINE( 752)						floatRef = shaderBuffer->paramRefs_Float->__get(floatIndex).StaticCast<  ::openfl::display::ShaderParameter_Float >();
HXLINE( 754)						{
HXLINE( 754)							int _g31 = (int)0;
HXDLIN( 754)							int _g22 = shaderBuffer->overrideCount;
HXDLIN( 754)							while((_g31 < _g22)){
HXLINE( 754)								_g31 = (_g31 + (int)1);
HXDLIN( 754)								int j1 = (_g31 - (int)1);
HXLINE( 756)								::String floatRef1 = floatRef->name;
HXDLIN( 756)								if ((floatRef1 == shaderBuffer->overrideNames->__get(j1))) {
HXLINE( 758)									overrideFloatValue = ::cpp::VirtualArray( shaderBuffer->overrideValues->__get(j1));
HXLINE( 759)									hasOverride = true;
HXLINE( 760)									goto _hx_goto_40;
            								}
            							}
            							_hx_goto_40:;
            						}
HXLINE( 766)						if (hasOverride) {
HXLINE( 768)							floatRef->_hx___updateGL(this->gl,overrideFloatValue);
            						}
            						else {
HXLINE( 772)							 ::lime::_backend::native::NativeGLRenderContext _hx_tmp1 = this->gl;
HXDLIN( 772)							int shaderBuffer2 = shaderBuffer->paramPositions->__get(i1);
HXDLIN( 772)							floatRef->_hx___updateGLFromBuffer(_hx_tmp1,paramData,shaderBuffer2,shaderBuffer->paramLengths->__get(i1));
            						}
HXLINE( 776)						floatIndex = (floatIndex + (int)1);
            					}
            					else {
HXLINE( 780)						intRef = shaderBuffer->paramRefs_Int->__get(intIndex).StaticCast<  ::openfl::display::ShaderParameter_Int >();
HXLINE( 782)						{
HXLINE( 782)							int _g32 = (int)0;
HXDLIN( 782)							int _g23 = shaderBuffer->overrideCount;
HXDLIN( 782)							while((_g32 < _g23)){
HXLINE( 782)								_g32 = (_g32 + (int)1);
HXDLIN( 782)								int j2 = (_g32 - (int)1);
HXLINE( 784)								::String intRef1 = intRef->name;
HXDLIN( 784)								if ((intRef1 == shaderBuffer->overrideNames->__get(j2))) {
HXLINE( 786)									overrideIntValue = ::cpp::VirtualArray( shaderBuffer->overrideValues->__get(j2));
HXLINE( 787)									hasOverride = true;
HXLINE( 788)									goto _hx_goto_41;
            								}
            							}
            							_hx_goto_41:;
            						}
HXLINE( 794)						if (hasOverride) {
HXLINE( 796)							intRef->_hx___updateGL(this->gl,overrideIntValue);
            						}
            						else {
HXLINE( 800)							 ::lime::_backend::native::NativeGLRenderContext _hx_tmp2 = this->gl;
HXDLIN( 800)							int shaderBuffer3 = shaderBuffer->paramPositions->__get(i1);
HXDLIN( 800)							intRef->_hx___updateGLFromBuffer(_hx_tmp2,paramData,shaderBuffer3,shaderBuffer->paramLengths->__get(i1));
            						}
HXLINE( 804)						intIndex = (intIndex + (int)1);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,_hx___updateGLFromBuffer,(void))

 ::Dynamic Shader_obj::get_data(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_820_get_data)
HXLINE( 822)		bool _hx_tmp;
HXDLIN( 822)		if (!(this->_hx___glSourceDirty)) {
HXLINE( 822)			_hx_tmp = hx::IsNull( this->_hx___data );
            		}
            		else {
HXLINE( 822)			_hx_tmp = true;
            		}
HXDLIN( 822)		if (_hx_tmp) {
HXLINE( 824)			this->_hx___init();
            		}
HXLINE( 828)		return this->_hx___data;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,get_data,return )

 ::Dynamic Shader_obj::set_data( ::Dynamic value){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_835_set_data)
HXDLIN( 835)		return (this->_hx___data = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,set_data,return )

::String Shader_obj::get_glFragmentSource(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_842_get_glFragmentSource)
HXDLIN( 842)		return this->_hx___glFragmentSource;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,get_glFragmentSource,return )

::String Shader_obj::set_glFragmentSource(::String value){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_847_set_glFragmentSource)
HXLINE( 849)		if ((value != this->_hx___glFragmentSource)) {
HXLINE( 851)			this->_hx___glSourceDirty = true;
            		}
HXLINE( 855)		return (this->_hx___glFragmentSource = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,set_glFragmentSource,return )

::String Shader_obj::get_glVertexSource(){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_862_get_glVertexSource)
HXDLIN( 862)		return this->_hx___glVertexSource;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shader_obj,get_glVertexSource,return )

::String Shader_obj::set_glVertexSource(::String value){
            	HX_STACKFRAME(&_hx_pos_4b006e5218f2daf8_867_set_glVertexSource)
HXLINE( 869)		if ((value != this->_hx___glVertexSource)) {
HXLINE( 871)			this->_hx___glSourceDirty = true;
            		}
HXLINE( 875)		return (this->_hx___glVertexSource = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,set_glVertexSource,return )

 ::haxe::ds::StringMap Shader_obj::_hx___glPrograms;


hx::ObjectPtr< Shader_obj > Shader_obj::__new( ::openfl::utils::ByteArrayData code) {
	hx::ObjectPtr< Shader_obj > __this = new Shader_obj();
	__this->__construct(code);
	return __this;
}

hx::ObjectPtr< Shader_obj > Shader_obj::__alloc(hx::Ctx *_hx_ctx, ::openfl::utils::ByteArrayData code) {
	Shader_obj *__this = (Shader_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Shader_obj), true, "openfl.display.Shader"));
	*(void **)__this = Shader_obj::_hx_vtable;
	__this->__construct(code);
	return __this;
}

Shader_obj::Shader_obj()
{
}

void Shader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Shader);
	HX_MARK_MEMBER_NAME(byteCode,"byteCode");
	HX_MARK_MEMBER_NAME(glProgram,"glProgram");
	HX_MARK_MEMBER_NAME(precisionHint,"precisionHint");
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(_hx___alpha,"__alpha");
	HX_MARK_MEMBER_NAME(_hx___bitmap,"__bitmap");
	HX_MARK_MEMBER_NAME(_hx___colorMultiplier,"__colorMultiplier");
	HX_MARK_MEMBER_NAME(_hx___colorOffset,"__colorOffset");
	HX_MARK_MEMBER_NAME(_hx___data,"__data");
	HX_MARK_MEMBER_NAME(_hx___glFragmentSource,"__glFragmentSource");
	HX_MARK_MEMBER_NAME(_hx___glSourceDirty,"__glSourceDirty");
	HX_MARK_MEMBER_NAME(_hx___glVertexSource,"__glVertexSource");
	HX_MARK_MEMBER_NAME(_hx___hasColorTransform,"__hasColorTransform");
	HX_MARK_MEMBER_NAME(_hx___inputBitmapData,"__inputBitmapData");
	HX_MARK_MEMBER_NAME(_hx___isGenerated,"__isGenerated");
	HX_MARK_MEMBER_NAME(_hx___matrix,"__matrix");
	HX_MARK_MEMBER_NAME(_hx___numPasses,"__numPasses");
	HX_MARK_MEMBER_NAME(_hx___paramBool,"__paramBool");
	HX_MARK_MEMBER_NAME(_hx___paramFloat,"__paramFloat");
	HX_MARK_MEMBER_NAME(_hx___paramInt,"__paramInt");
	HX_MARK_MEMBER_NAME(_hx___position,"__position");
	HX_MARK_MEMBER_NAME(_hx___textureCoord,"__textureCoord");
	HX_MARK_MEMBER_NAME(_hx___texture,"__texture");
	HX_MARK_MEMBER_NAME(_hx___textureSize,"__textureSize");
	HX_MARK_END_CLASS();
}

void Shader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(byteCode,"byteCode");
	HX_VISIT_MEMBER_NAME(glProgram,"glProgram");
	HX_VISIT_MEMBER_NAME(precisionHint,"precisionHint");
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(_hx___alpha,"__alpha");
	HX_VISIT_MEMBER_NAME(_hx___bitmap,"__bitmap");
	HX_VISIT_MEMBER_NAME(_hx___colorMultiplier,"__colorMultiplier");
	HX_VISIT_MEMBER_NAME(_hx___colorOffset,"__colorOffset");
	HX_VISIT_MEMBER_NAME(_hx___data,"__data");
	HX_VISIT_MEMBER_NAME(_hx___glFragmentSource,"__glFragmentSource");
	HX_VISIT_MEMBER_NAME(_hx___glSourceDirty,"__glSourceDirty");
	HX_VISIT_MEMBER_NAME(_hx___glVertexSource,"__glVertexSource");
	HX_VISIT_MEMBER_NAME(_hx___hasColorTransform,"__hasColorTransform");
	HX_VISIT_MEMBER_NAME(_hx___inputBitmapData,"__inputBitmapData");
	HX_VISIT_MEMBER_NAME(_hx___isGenerated,"__isGenerated");
	HX_VISIT_MEMBER_NAME(_hx___matrix,"__matrix");
	HX_VISIT_MEMBER_NAME(_hx___numPasses,"__numPasses");
	HX_VISIT_MEMBER_NAME(_hx___paramBool,"__paramBool");
	HX_VISIT_MEMBER_NAME(_hx___paramFloat,"__paramFloat");
	HX_VISIT_MEMBER_NAME(_hx___paramInt,"__paramInt");
	HX_VISIT_MEMBER_NAME(_hx___position,"__position");
	HX_VISIT_MEMBER_NAME(_hx___textureCoord,"__textureCoord");
	HX_VISIT_MEMBER_NAME(_hx___texture,"__texture");
	HX_VISIT_MEMBER_NAME(_hx___textureSize,"__textureSize");
}

hx::Val Shader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return hx::Val( gl ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_data() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"__data") ) { return hx::Val( _hx___data ); }
		if (HX_FIELD_EQ(inName,"__init") ) { return hx::Val( _hx___init_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"__alpha") ) { return hx::Val( _hx___alpha ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"byteCode") ) { return hx::Val( byteCode ); }
		if (HX_FIELD_EQ(inName,"__bitmap") ) { return hx::Val( _hx___bitmap ); }
		if (HX_FIELD_EQ(inName,"__matrix") ) { return hx::Val( _hx___matrix ); }
		if (HX_FIELD_EQ(inName,"__enable") ) { return hx::Val( _hx___enable_dyn() ); }
		if (HX_FIELD_EQ(inName,"__initGL") ) { return hx::Val( _hx___initGL_dyn() ); }
		if (HX_FIELD_EQ(inName,"__update") ) { return hx::Val( _hx___update_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_data") ) { return hx::Val( get_data_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_data") ) { return hx::Val( set_data_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"glProgram") ) { return hx::Val( glProgram ); }
		if (HX_FIELD_EQ(inName,"__texture") ) { return hx::Val( _hx___texture ); }
		if (HX_FIELD_EQ(inName,"__disable") ) { return hx::Val( _hx___disable_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__paramInt") ) { return hx::Val( _hx___paramInt ); }
		if (HX_FIELD_EQ(inName,"__position") ) { return hx::Val( _hx___position ); }
		if (HX_FIELD_EQ(inName,"__enableGL") ) { return hx::Val( _hx___enableGL_dyn() ); }
		if (HX_FIELD_EQ(inName,"__updateGL") ) { return hx::Val( _hx___updateGL_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__numPasses") ) { return hx::Val( _hx___numPasses ); }
		if (HX_FIELD_EQ(inName,"__paramBool") ) { return hx::Val( _hx___paramBool ); }
		if (HX_FIELD_EQ(inName,"__disableGL") ) { return hx::Val( _hx___disableGL_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__paramFloat") ) { return hx::Val( _hx___paramFloat ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"precisionHint") ) { return hx::Val( precisionHint ); }
		if (HX_FIELD_EQ(inName,"__colorOffset") ) { return hx::Val( _hx___colorOffset ); }
		if (HX_FIELD_EQ(inName,"__isGenerated") ) { return hx::Val( _hx___isGenerated ); }
		if (HX_FIELD_EQ(inName,"__textureSize") ) { return hx::Val( _hx___textureSize ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glVertexSource") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_glVertexSource() ); }
		if (HX_FIELD_EQ(inName,"__textureCoord") ) { return hx::Val( _hx___textureCoord ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__glSourceDirty") ) { return hx::Val( _hx___glSourceDirty ); }
		if (HX_FIELD_EQ(inName,"__clearUseArray") ) { return hx::Val( _hx___clearUseArray_dyn() ); }
		if (HX_FIELD_EQ(inName,"__processGLData") ) { return hx::Val( _hx___processGLData_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"glFragmentSource") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_glFragmentSource() ); }
		if (HX_FIELD_EQ(inName,"__glVertexSource") ) { return hx::Val( _hx___glVertexSource ); }
		if (HX_FIELD_EQ(inName,"__createGLShader") ) { return hx::Val( _hx___createGLShader_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__colorMultiplier") ) { return hx::Val( _hx___colorMultiplier ); }
		if (HX_FIELD_EQ(inName,"__inputBitmapData") ) { return hx::Val( _hx___inputBitmapData ); }
		if (HX_FIELD_EQ(inName,"__createGLProgram") ) { return hx::Val( _hx___createGLProgram_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__glFragmentSource") ) { return hx::Val( _hx___glFragmentSource ); }
		if (HX_FIELD_EQ(inName,"__updateFromBuffer") ) { return hx::Val( _hx___updateFromBuffer_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_glVertexSource") ) { return hx::Val( get_glVertexSource_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_glVertexSource") ) { return hx::Val( set_glVertexSource_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__hasColorTransform") ) { return hx::Val( _hx___hasColorTransform ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"__updateGLFromBuffer") ) { return hx::Val( _hx___updateGLFromBuffer_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_glFragmentSource") ) { return hx::Val( get_glFragmentSource_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_glFragmentSource") ) { return hx::Val( set_glFragmentSource_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Shader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"__glPrograms") ) { outValue = ( _hx___glPrograms ); return true; }
	}
	return false;
}

hx::Val Shader_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::_backend::native::NativeGLRenderContext >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_data(inValue.Cast<  ::Dynamic >()) ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"__data") ) { _hx___data=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"__alpha") ) { _hx___alpha=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"byteCode") ) { byteCode=inValue.Cast<  ::openfl::utils::ByteArrayData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__bitmap") ) { _hx___bitmap=inValue.Cast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__matrix") ) { _hx___matrix=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"glProgram") ) { glProgram=inValue.Cast<  ::lime::graphics::opengl::GLObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__texture") ) { _hx___texture=inValue.Cast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__paramInt") ) { _hx___paramInt=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__position") ) { _hx___position=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__numPasses") ) { _hx___numPasses=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__paramBool") ) { _hx___paramBool=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__paramFloat") ) { _hx___paramFloat=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"precisionHint") ) { precisionHint=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__colorOffset") ) { _hx___colorOffset=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__isGenerated") ) { _hx___isGenerated=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__textureSize") ) { _hx___textureSize=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"glVertexSource") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_glVertexSource(inValue.Cast< ::String >()) ); }
		if (HX_FIELD_EQ(inName,"__textureCoord") ) { _hx___textureCoord=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__glSourceDirty") ) { _hx___glSourceDirty=inValue.Cast< bool >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"glFragmentSource") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_glFragmentSource(inValue.Cast< ::String >()) ); }
		if (HX_FIELD_EQ(inName,"__glVertexSource") ) { _hx___glVertexSource=inValue.Cast< ::String >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__colorMultiplier") ) { _hx___colorMultiplier=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__inputBitmapData") ) { _hx___inputBitmapData=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__glFragmentSource") ) { _hx___glFragmentSource=inValue.Cast< ::String >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__hasColorTransform") ) { _hx___hasColorTransform=inValue.Cast<  ::openfl::display::ShaderParameter_Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Shader_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"__glPrograms") ) { _hx___glPrograms=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

void Shader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("byteCode","\x55","\x20","\x71","\x42"));
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	outFields->push(HX_HCSTRING("glFragmentSource","\xd0","\xc5","\xca","\xf7"));
	outFields->push(HX_HCSTRING("glProgram","\xdf","\xd6","\xb3","\xc1"));
	outFields->push(HX_HCSTRING("glVertexSource","\x24","\x6d","\x4a","\x5b"));
	outFields->push(HX_HCSTRING("precisionHint","\xe5","\xb5","\x95","\x2c"));
	outFields->push(HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"));
	outFields->push(HX_HCSTRING("__alpha","\x3e","\x00","\xf5","\x8b"));
	outFields->push(HX_HCSTRING("__bitmap","\x0f","\x7b","\x3b","\x99"));
	outFields->push(HX_HCSTRING("__colorMultiplier","\xa4","\x47","\xdb","\xd3"));
	outFields->push(HX_HCSTRING("__colorOffset","\x36","\x6a","\xe0","\x62"));
	outFields->push(HX_HCSTRING("__data","\x4a","\xb9","\x5b","\xf1"));
	outFields->push(HX_HCSTRING("__glFragmentSource","\xf0","\x58","\x5b","\x63"));
	outFields->push(HX_HCSTRING("__glSourceDirty","\xf2","\xa3","\xef","\x41"));
	outFields->push(HX_HCSTRING("__glVertexSource","\x44","\xf8","\x89","\x8f"));
	outFields->push(HX_HCSTRING("__hasColorTransform","\x63","\x3d","\xdb","\xa3"));
	outFields->push(HX_HCSTRING("__inputBitmapData","\x43","\xdf","\xf6","\x64"));
	outFields->push(HX_HCSTRING("__isGenerated","\x25","\xe7","\x69","\xbb"));
	outFields->push(HX_HCSTRING("__matrix","\x61","\xa1","\xf7","\x63"));
	outFields->push(HX_HCSTRING("__numPasses","\x45","\x67","\x5f","\xcd"));
	outFields->push(HX_HCSTRING("__paramBool","\x37","\x44","\xb6","\x5f"));
	outFields->push(HX_HCSTRING("__paramFloat","\xef","\x10","\x64","\xab"));
	outFields->push(HX_HCSTRING("__paramInt","\x82","\xcd","\xbd","\x21"));
	outFields->push(HX_HCSTRING("__position","\xc9","\x13","\x33","\x6e"));
	outFields->push(HX_HCSTRING("__textureCoord","\xfa","\xea","\xbe","\x63"));
	outFields->push(HX_HCSTRING("__texture","\xbb","\x19","\x2f","\x20"));
	outFields->push(HX_HCSTRING("__textureSize","\x1c","\xe0","\x4a","\x4b"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Shader_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::utils::ByteArrayData*/ ,(int)offsetof(Shader_obj,byteCode),HX_HCSTRING("byteCode","\x55","\x20","\x71","\x42")},
	{hx::fsObject /*::lime::graphics::opengl::GLObject*/ ,(int)offsetof(Shader_obj,glProgram),HX_HCSTRING("glProgram","\xdf","\xd6","\xb3","\xc1")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Shader_obj,precisionHint),HX_HCSTRING("precisionHint","\xe5","\xb5","\x95","\x2c")},
	{hx::fsObject /*::lime::_backend::native::NativeGLRenderContext*/ ,(int)offsetof(Shader_obj,gl),HX_HCSTRING("gl","\x25","\x5a","\x00","\x00")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___alpha),HX_HCSTRING("__alpha","\x3e","\x00","\xf5","\x8b")},
	{hx::fsObject /*::openfl::display::ShaderInput_openfl_display_BitmapData*/ ,(int)offsetof(Shader_obj,_hx___bitmap),HX_HCSTRING("__bitmap","\x0f","\x7b","\x3b","\x99")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___colorMultiplier),HX_HCSTRING("__colorMultiplier","\xa4","\x47","\xdb","\xd3")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___colorOffset),HX_HCSTRING("__colorOffset","\x36","\x6a","\xe0","\x62")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Shader_obj,_hx___data),HX_HCSTRING("__data","\x4a","\xb9","\x5b","\xf1")},
	{hx::fsString,(int)offsetof(Shader_obj,_hx___glFragmentSource),HX_HCSTRING("__glFragmentSource","\xf0","\x58","\x5b","\x63")},
	{hx::fsBool,(int)offsetof(Shader_obj,_hx___glSourceDirty),HX_HCSTRING("__glSourceDirty","\xf2","\xa3","\xef","\x41")},
	{hx::fsString,(int)offsetof(Shader_obj,_hx___glVertexSource),HX_HCSTRING("__glVertexSource","\x44","\xf8","\x89","\x8f")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Bool*/ ,(int)offsetof(Shader_obj,_hx___hasColorTransform),HX_HCSTRING("__hasColorTransform","\x63","\x3d","\xdb","\xa3")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Shader_obj,_hx___inputBitmapData),HX_HCSTRING("__inputBitmapData","\x43","\xdf","\xf6","\x64")},
	{hx::fsBool,(int)offsetof(Shader_obj,_hx___isGenerated),HX_HCSTRING("__isGenerated","\x25","\xe7","\x69","\xbb")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___matrix),HX_HCSTRING("__matrix","\x61","\xa1","\xf7","\x63")},
	{hx::fsInt,(int)offsetof(Shader_obj,_hx___numPasses),HX_HCSTRING("__numPasses","\x45","\x67","\x5f","\xcd")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Shader_obj,_hx___paramBool),HX_HCSTRING("__paramBool","\x37","\x44","\xb6","\x5f")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Shader_obj,_hx___paramFloat),HX_HCSTRING("__paramFloat","\xef","\x10","\x64","\xab")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Shader_obj,_hx___paramInt),HX_HCSTRING("__paramInt","\x82","\xcd","\xbd","\x21")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___position),HX_HCSTRING("__position","\xc9","\x13","\x33","\x6e")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___textureCoord),HX_HCSTRING("__textureCoord","\xfa","\xea","\xbe","\x63")},
	{hx::fsObject /*::openfl::display::ShaderInput_openfl_display_BitmapData*/ ,(int)offsetof(Shader_obj,_hx___texture),HX_HCSTRING("__texture","\xbb","\x19","\x2f","\x20")},
	{hx::fsObject /*::openfl::display::ShaderParameter_Float*/ ,(int)offsetof(Shader_obj,_hx___textureSize),HX_HCSTRING("__textureSize","\x1c","\xe0","\x4a","\x4b")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Shader_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(void *) &Shader_obj::_hx___glPrograms,HX_HCSTRING("__glPrograms","\xd4","\xa7","\x3b","\xf4")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Shader_obj_sMemberFields[] = {
	HX_HCSTRING("byteCode","\x55","\x20","\x71","\x42"),
	HX_HCSTRING("glProgram","\xdf","\xd6","\xb3","\xc1"),
	HX_HCSTRING("precisionHint","\xe5","\xb5","\x95","\x2c"),
	HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"),
	HX_HCSTRING("__alpha","\x3e","\x00","\xf5","\x8b"),
	HX_HCSTRING("__bitmap","\x0f","\x7b","\x3b","\x99"),
	HX_HCSTRING("__colorMultiplier","\xa4","\x47","\xdb","\xd3"),
	HX_HCSTRING("__colorOffset","\x36","\x6a","\xe0","\x62"),
	HX_HCSTRING("__data","\x4a","\xb9","\x5b","\xf1"),
	HX_HCSTRING("__glFragmentSource","\xf0","\x58","\x5b","\x63"),
	HX_HCSTRING("__glSourceDirty","\xf2","\xa3","\xef","\x41"),
	HX_HCSTRING("__glVertexSource","\x44","\xf8","\x89","\x8f"),
	HX_HCSTRING("__hasColorTransform","\x63","\x3d","\xdb","\xa3"),
	HX_HCSTRING("__inputBitmapData","\x43","\xdf","\xf6","\x64"),
	HX_HCSTRING("__isGenerated","\x25","\xe7","\x69","\xbb"),
	HX_HCSTRING("__matrix","\x61","\xa1","\xf7","\x63"),
	HX_HCSTRING("__numPasses","\x45","\x67","\x5f","\xcd"),
	HX_HCSTRING("__paramBool","\x37","\x44","\xb6","\x5f"),
	HX_HCSTRING("__paramFloat","\xef","\x10","\x64","\xab"),
	HX_HCSTRING("__paramInt","\x82","\xcd","\xbd","\x21"),
	HX_HCSTRING("__position","\xc9","\x13","\x33","\x6e"),
	HX_HCSTRING("__textureCoord","\xfa","\xea","\xbe","\x63"),
	HX_HCSTRING("__texture","\xbb","\x19","\x2f","\x20"),
	HX_HCSTRING("__textureSize","\x1c","\xe0","\x4a","\x4b"),
	HX_HCSTRING("__clearUseArray","\x5f","\x0b","\x0a","\xa8"),
	HX_HCSTRING("__createGLShader","\x46","\x69","\xda","\x33"),
	HX_HCSTRING("__createGLProgram","\x43","\x7d","\xb4","\xbf"),
	HX_HCSTRING("__disable","\xc8","\xba","\xa6","\x32"),
	HX_HCSTRING("__disableGL","\xed","\x3a","\xe1","\x35"),
	HX_HCSTRING("__enable","\xa3","\x19","\xb7","\xa0"),
	HX_HCSTRING("__enableGL","\x88","\x46","\xeb","\x8f"),
	HX_HCSTRING("__init","\x30","\x9e","\xb3","\xf4"),
	HX_HCSTRING("__initGL","\x55","\xc8","\x7b","\x3f"),
	HX_HCSTRING("__processGLData","\x7e","\x0f","\x78","\x7c"),
	HX_HCSTRING("__update","\x29","\xf1","\x34","\x2f"),
	HX_HCSTRING("__updateFromBuffer","\x93","\x24","\x55","\xc9"),
	HX_HCSTRING("__updateGL","\x8e","\x8b","\x32","\x1b"),
	HX_HCSTRING("__updateGLFromBuffer","\x38","\x8f","\xd7","\x17"),
	HX_HCSTRING("get_data","\xb3","\x11","\x1e","\xc2"),
	HX_HCSTRING("set_data","\x27","\x6b","\x7b","\x70"),
	HX_HCSTRING("get_glFragmentSource","\xd9","\x2a","\x35","\x16"),
	HX_HCSTRING("set_glFragmentSource","\x4d","\xe2","\xec","\xe2"),
	HX_HCSTRING("get_glVertexSource","\xed","\x4d","\xe4","\xf6"),
	HX_HCSTRING("set_glVertexSource","\x61","\x80","\x93","\xd3"),
	::String(null()) };

static void Shader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Shader_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Shader_obj::_hx___glPrograms,"__glPrograms");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Shader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Shader_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Shader_obj::_hx___glPrograms,"__glPrograms");
};

#endif

hx::Class Shader_obj::__mClass;

static ::String Shader_obj_sStaticFields[] = {
	HX_HCSTRING("__glPrograms","\xd4","\xa7","\x3b","\xf4"),
	::String(null())
};

void Shader_obj::__register()
{
	hx::Object *dummy = new Shader_obj;
	Shader_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.display.Shader","\x0f","\xdf","\x61","\xa7");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Shader_obj::__GetStatic;
	__mClass->mSetStaticField = &Shader_obj::__SetStatic;
	__mClass->mMarkFunc = Shader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Shader_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Shader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Shader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Shader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Shader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Shader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Shader_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_4b006e5218f2daf8_29_boot)
HXDLIN(  29)		_hx___glPrograms =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace openfl
} // end namespace display
