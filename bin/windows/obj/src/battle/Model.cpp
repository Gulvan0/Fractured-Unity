// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Element
#include <Element.h>
#endif
#ifndef INCLUDED_ID
#include <ID.h>
#endif
#ifndef INCLUDED_Lambda
#include <Lambda.h>
#endif
#ifndef INCLUDED_MathUtils
#include <MathUtils.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_XMLUtils
#include <XMLUtils.h>
#endif
#ifndef INCLUDED_battle_Ability
#include <battle/Ability.h>
#endif
#ifndef INCLUDED_battle_Active
#include <battle/Active.h>
#endif
#ifndef INCLUDED_battle_Buff
#include <battle/Buff.h>
#endif
#ifndef INCLUDED_battle_ChooseResult
#include <battle/ChooseResult.h>
#endif
#ifndef INCLUDED_battle_IModelObserver
#include <battle/IModelObserver.h>
#endif
#ifndef INCLUDED_battle_IMutableModel
#include <battle/IMutableModel.h>
#endif
#ifndef INCLUDED_battle_IObservableModel
#include <battle/IObservableModel.h>
#endif
#ifndef INCLUDED_battle_ISimpleModel
#include <battle/ISimpleModel.h>
#endif
#ifndef INCLUDED_battle_Model
#include <battle/Model.h>
#endif
#ifndef INCLUDED_battle_TargetResult
#include <battle/TargetResult.h>
#endif
#ifndef INCLUDED_battle_Unit
#include <battle/Unit.h>
#endif
#ifndef INCLUDED_battle_Utils
#include <battle/Utils.h>
#endif
#ifndef INCLUDED_battle_data_Abilities
#include <battle/data/Abilities.h>
#endif
#ifndef INCLUDED_battle_data_Buffs
#include <battle/data/Buffs.h>
#endif
#ifndef INCLUDED_battle_data_Passives
#include <battle/data/Passives.h>
#endif
#ifndef INCLUDED_battle_data_Units
#include <battle/data/Units.h>
#endif
#ifndef INCLUDED_battle_enums_AbilityTarget
#include <battle/enums/AbilityTarget.h>
#endif
#ifndef INCLUDED_battle_enums_AbilityType
#include <battle/enums/AbilityType.h>
#endif
#ifndef INCLUDED_battle_enums_InputMode
#include <battle/enums/InputMode.h>
#endif
#ifndef INCLUDED_battle_enums_Source
#include <battle/enums/Source.h>
#endif
#ifndef INCLUDED_battle_enums_StrikeType
#include <battle/enums/StrikeType.h>
#endif
#ifndef INCLUDED_battle_enums_Team
#include <battle/enums/Team.h>
#endif
#ifndef INCLUDED_battle_enums_UnitType
#include <battle/enums/UnitType.h>
#endif
#ifndef INCLUDED_battle_struct_BuffQueue
#include <battle/struct/BuffQueue.h>
#endif
#ifndef INCLUDED_battle_struct_Countdown
#include <battle/struct/Countdown.h>
#endif
#ifndef INCLUDED_battle_struct_FloatPool
#include <battle/struct/FloatPool.h>
#endif
#ifndef INCLUDED_battle_struct_Pool
#include <battle/struct/Pool.h>
#endif
#ifndef INCLUDED_battle_struct_UPair
#include <battle/struct/UPair.h>
#endif
#ifndef INCLUDED_battle_struct_UnitCoords
#include <battle/struct/UnitCoords.h>
#endif
#ifndef INCLUDED_battle_struct_Wheel
#include <battle/struct/Wheel.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_653930ec9597c981_538_new,"battle.Model","new",0xd55a3245,"battle.Model.new","battle/Model.hx",538,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_66_getUnits,"battle.Model","getUnits",0x69b218f4,"battle.Model.getUnits","battle/Model.hx",66,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_71_getInputMode,"battle.Model","getInputMode",0xb324e692,"battle.Model.getInputMode","battle/Model.hx",71,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_79_changeHP,"battle.Model","changeHP",0xc941ac73,"battle.Model.changeHP","battle/Model.hx",79,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_106_changeMana,"battle.Model","changeMana",0xe1b746d2,"battle.Model.changeMana","battle/Model.hx",106,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_116_changeAlacrity,"battle.Model","changeAlacrity",0xdadab5d4,"battle.Model.changeAlacrity","battle/Model.hx",116,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_126_castBuff,"battle.Model","castBuff",0x3496c02d,"battle.Model.castBuff","battle/Model.hx",126,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_139_dispellBuffs,"battle.Model","dispellBuffs",0x61eb69b8,"battle.Model.dispellBuffs","battle/Model.hx",139,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_152_choose,"battle.Model","choose",0x087e7612,"battle.Model.choose","battle/Model.hx",152,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_175_targetAndUse,"battle.Model","targetAndUse",0xb1d2fd5c,"battle.Model.targetAndUse","battle/Model.hx",175,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_203_useAbility,"battle.Model","useAbility",0x6f2c58de,"battle.Model.useAbility","battle/Model.hx",203,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_245_setUA,"battle.Model","setUA",0x66fdf793,"battle.Model.setUA","battle/Model.hx",245,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_252_clearUA,"battle.Model","clearUA",0x3452b17e,"battle.Model.clearUA","battle/Model.hx",252,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_265_alacrityIncrement,"battle.Model","alacrityIncrement",0x763fbb8b,"battle.Model.alacrityIncrement","battle/Model.hx",265,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_286_processReady,"battle.Model","processReady",0x62b1f4ef,"battle.Model.processReady","battle/Model.hx",286,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_307_postTurnProcess,"battle.Model","postTurnProcess",0xbf04cd57,"battle.Model.postTurnProcess","battle/Model.hx",307,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_333_botMakeTurn,"battle.Model","botMakeTurn",0xddea8897,"battle.Model.botMakeTurn","battle/Model.hx",333,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_341_getAlacrityGain,"battle.Model","getAlacrityGain",0x377dfa43,"battle.Model.getAlacrityGain","battle/Model.hx",341,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_353_sortByFlow,"battle.Model","sortByFlow",0x250a1c1e,"battle.Model.sortByFlow","battle/Model.hx",353,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_351_sortByFlow,"battle.Model","sortByFlow",0x250a1c1e,"battle.Model.sortByFlow","battle/Model.hx",351,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_373_end,"battle.Model","end",0xd55365c0,"battle.Model.end","battle/Model.hx",373,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_379_defineWinner,"battle.Model","defineWinner",0xc04729d5,"battle.Model.defineWinner","battle/Model.hx",379,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_388_checkAlive,"battle.Model","checkAlive",0xf0993aa0,"battle.Model.checkAlive","battle/Model.hx",388,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_397_bothTeamsAlive,"battle.Model","bothTeamsAlive",0x81a1c4d3,"battle.Model.bothTeamsAlive","battle/Model.hx",397,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_406_skipTurn,"battle.Model","skipTurn",0x264e7997,"battle.Model.skipTurn","battle/Model.hx",406,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_416_quit,"battle.Model","quit",0xdb99864a,"battle.Model.quit","battle/Model.hx",416,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_420_printAbilityInfo,"battle.Model","printAbilityInfo",0x3191fb06,"battle.Model.printAbilityInfo","battle/Model.hx",420,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_446_printUnitInfo,"battle.Model","printUnitInfo",0xd4b3dc84,"battle.Model.printUnitInfo","battle/Model.hx",446,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_470_addObserver,"battle.Model","addObserver",0xcd6cc23c,"battle.Model.addObserver","battle/Model.hx",470,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_477_respond,"battle.Model","respond",0xf11941ba,"battle.Model.respond","battle/Model.hx",477,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_494_checkChoose,"battle.Model","checkChoose",0x18887ca4,"battle.Model.checkChoose","battle/Model.hx",494,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_513_checkTarget,"battle.Model","checkTarget",0xdec1151e,"battle.Model.checkTarget","battle/Model.hx",513,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_529_targetAvaibility,"battle.Model","targetAvaibility",0x51506112,"battle.Model.targetAvaibility","battle/Model.hx",529,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_550_init,"battle.Model","init",0xd64a818b,"battle.Model.init","battle/Model.hx",550,0xce28e5cc)
namespace battle{

void Model_obj::__construct(::Array< ::Dynamic> allies,::Array< ::Dynamic> enemies){
            	HX_GC_STACKFRAME(&_hx_pos_653930ec9597c981_538_new)
HXLINE( 539)		this->units =  ::battle::_hx_struct::UPair_obj::__alloc( HX_CTX ,allies,enemies);
HXLINE( 540)		this->readyUnits = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 541)		this->chosenAbilityPos = (int)-1;
HXLINE( 542)		this->inputMode = ::battle::enums::InputMode_obj::None_dyn();
HXLINE( 543)		this->observers = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 544)		this->responsesLeft = (int)0;
HXLINE( 545)		this->continueArgs = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 546)		this->clearUA();
            	}

Dynamic Model_obj::__CreateEmpty() { return new Model_obj; }

void *Model_obj::_hx_vtable = 0;

Dynamic Model_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Model_obj > _hx_result = new Model_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Model_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x05fd5cc9;
}

static ::battle::IMutableModel_obj _hx_battle_Model__hx_battle_IMutableModel= {
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,int, ::Element, ::battle::enums::Source))&::battle::Model_obj::changeHP,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,int, ::battle::enums::Source))&::battle::Model_obj::changeMana,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,Float, ::battle::enums::Source))&::battle::Model_obj::changeAlacrity,
	( void (hx::Object::*)( ::ID, ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,int))&::battle::Model_obj::castBuff,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords,::Array< ::Dynamic>, ::Dynamic))&::battle::Model_obj::dispellBuffs,
	(  ::battle::_hx_struct::UPair (hx::Object::*)())&::battle::Model_obj::getUnits,
};

static ::battle::IObservableModel_obj _hx_battle_Model__hx_battle_IObservableModel= {
	(  ::battle::enums::InputMode (hx::Object::*)())&::battle::Model_obj::getInputMode,
	( bool (hx::Object::*)( ::battle::_hx_struct::UnitCoords))&::battle::Model_obj::targetAvaibility,
	( void (hx::Object::*)(int))&::battle::Model_obj::choose,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords))&::battle::Model_obj::targetAndUse,
	( void (hx::Object::*)(int))&::battle::Model_obj::printAbilityInfo,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords))&::battle::Model_obj::printUnitInfo,
	( void (hx::Object::*)())&::battle::Model_obj::skipTurn,
	( void (hx::Object::*)())&::battle::Model_obj::quit,
	( void (hx::Object::*)())&::battle::Model_obj::respond,
};

static ::battle::ISimpleModel_obj _hx_battle_Model__hx_battle_ISimpleModel= {
	(  ::battle::_hx_struct::UPair (hx::Object::*)())&::battle::Model_obj::getUnits,
	( void (hx::Object::*)())&::battle::Model_obj::respond,
};

void *Model_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x315d9f14: return &_hx_battle_Model__hx_battle_IMutableModel;
		case (int)0xf5b152d5: return &_hx_battle_Model__hx_battle_IObservableModel;
		case (int)0x4a70be46: return &_hx_battle_Model__hx_battle_ISimpleModel;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

 ::battle::_hx_struct::UPair Model_obj::getUnits(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_66_getUnits)
HXDLIN(  66)		return this->units;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,getUnits,return )

 ::battle::enums::InputMode Model_obj::getInputMode(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_71_getInputMode)
HXDLIN(  71)		return this->inputMode;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,getInputMode,return )

void Model_obj::changeHP( ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,int dhp, ::Element element, ::battle::enums::Source source){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_79_changeHP)
HXLINE(  80)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE(  81)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE(  82)		bool crit = false;
HXLINE(  84)		if (hx::IsNotEq( source,::battle::enums::Source_obj::God_dyn() )) {
HXLINE(  86)			dhp = ::battle::Utils_obj::calcBoost(dhp,caster,target);
HXLINE(  88)			if (::battle::Utils_obj::flipCrit(caster)) {
HXLINE(  90)				crit = true;
HXLINE(  91)				dhp = ::battle::Utils_obj::calcCrit(dhp,caster);
            			}
            		}
HXLINE(  94)		 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  94)		::String _hx_tmp1;
HXDLIN(  94)		if (crit) {
HXLINE(  94)			_hx_tmp1 = HX_("!",21,00,00,00);
            		}
            		else {
HXLINE(  94)			_hx_tmp1 = HX_("",00,00,00,00);
            		}
HXDLIN(  94)		_hx_tmp((((((caster->name + HX_(" deals ",19,8e,47,96)) + -(dhp)) + _hx_tmp1) + HX_(" damage to ",34,96,33,ae)) + target->name),hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),94,HX_("battle.Model",d3,ab,e0,43),HX_("changeHP",78,0c,4e,66)));
HXLINE(  95)		{
HXLINE(  95)			 ::battle::_hx_struct::Pool _g = target->hpPool;
HXDLIN(  95)			_g->set_value((_g->value + dhp));
            		}
HXLINE(  96)		 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN(  96)		::String _hx_tmp3 = (target->name + HX_(" is still alive: ",25,5e,7b,46));
HXDLIN(  96)		::String _hx_tmp4 = (_hx_tmp3 + ::Std_obj::string(target->isAlive()));
HXDLIN(  96)		_hx_tmp2(_hx_tmp4,hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),96,HX_("battle.Model",d3,ab,e0,43),HX_("changeHP",78,0c,4e,66)));
HXLINE(  97)		{
HXLINE(  97)			int _g1 = (int)0;
HXDLIN(  97)			::Array< ::Dynamic> _g11 = this->observers;
HXDLIN(  97)			while((_g1 < _g11->length)){
HXLINE(  97)				::Dynamic o = _g11->__get(_g1);
HXDLIN(  97)				_g1 = (_g1 + (int)1);
HXLINE(  99)				::battle::IModelObserver_obj::hpUpdate(o,target,dhp,element,crit,source);
HXLINE( 100)				if (!(target->isAlive())) {
HXLINE( 101)					::battle::IModelObserver_obj::death(o,targetCoords);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Model_obj,changeHP,(void))

void Model_obj::changeMana( ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,int dmana, ::battle::enums::Source source){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_106_changeMana)
HXLINE( 107)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 108)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE( 110)		{
HXLINE( 110)			 ::battle::_hx_struct::Pool _g = target->manaPool;
HXDLIN( 110)			_g->set_value((_g->value + dmana));
            		}
HXLINE( 112)		{
HXLINE( 112)			int _g1 = (int)0;
HXDLIN( 112)			::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 112)			while((_g1 < _g11->length)){
HXLINE( 112)				::Dynamic o = _g11->__get(_g1);
HXDLIN( 112)				_g1 = (_g1 + (int)1);
HXDLIN( 112)				::battle::IModelObserver_obj::manaUpdate(o,target,dmana,source);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Model_obj,changeMana,(void))

void Model_obj::changeAlacrity( ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,Float dalac, ::battle::enums::Source source){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_116_changeAlacrity)
HXLINE( 117)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 118)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE( 120)		{
HXLINE( 120)			 ::battle::_hx_struct::FloatPool _g = target->alacrityPool;
HXDLIN( 120)			_g->set_value((_g->value + dalac));
            		}
HXLINE( 122)		{
HXLINE( 122)			int _g1 = (int)0;
HXDLIN( 122)			::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 122)			while((_g1 < _g11->length)){
HXLINE( 122)				::Dynamic o = _g11->__get(_g1);
HXDLIN( 122)				_g1 = (_g1 + (int)1);
HXDLIN( 122)				::battle::IModelObserver_obj::alacUpdate(o,target,dalac,source);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Model_obj,changeAlacrity,(void))

void Model_obj::castBuff( ::ID id, ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,int duration){
            	HX_GC_STACKFRAME(&_hx_pos_653930ec9597c981_126_castBuff)
HXLINE( 127)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 128)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE( 130)		if (targetCoords->equals(casterCoords)) {
HXLINE( 131)			duration = (duration + (int)1);
            		}
HXLINE( 133)		 ::battle::_hx_struct::BuffQueue target1 = target->buffQueue;
HXDLIN( 133)		target1->addBuff( ::battle::Buff_obj::__alloc( HX_CTX ,id,duration,targetCoords,casterCoords));
HXLINE( 135)		{
HXLINE( 135)			int _g = (int)0;
HXDLIN( 135)			::Array< ::Dynamic> _g1 = this->observers;
HXDLIN( 135)			while((_g < _g1->length)){
HXLINE( 135)				::Dynamic o = _g1->__get(_g);
HXDLIN( 135)				_g = (_g + (int)1);
HXDLIN( 135)				::battle::IModelObserver_obj::buffQueueUpdate(o,targetCoords,target->buffQueue->queue);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Model_obj,castBuff,(void))

void Model_obj::dispellBuffs( ::battle::_hx_struct::UnitCoords targetCoords,::Array< ::Dynamic> elements, ::Dynamic __o_count){
 ::Dynamic count = __o_count.Default(-1);
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_139_dispellBuffs)
HXLINE( 140)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 142)		target->buffQueue->dispellByElement(elements,count);
HXLINE( 144)		{
HXLINE( 144)			int _g = (int)0;
HXDLIN( 144)			::Array< ::Dynamic> _g1 = this->observers;
HXDLIN( 144)			while((_g < _g1->length)){
HXLINE( 144)				::Dynamic o = _g1->__get(_g);
HXDLIN( 144)				_g = (_g + (int)1);
HXDLIN( 144)				::battle::IModelObserver_obj::buffQueueUpdate(o,targetCoords,target->buffQueue->queue);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Model_obj,dispellBuffs,(void))

void Model_obj::choose(int abilityPos){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_152_choose)
HXLINE( 153)		 ::battle::Ability ability = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->get(abilityPos);
HXLINE( 155)		{
HXLINE( 155)			 ::battle::ChooseResult _g = this->checkChoose(abilityPos);
HXDLIN( 155)			switch((int)(_hx_getEnumValueIndex(_g))){
            				case (int)0: {
HXLINE( 158)					this->inputMode = ::battle::enums::InputMode_obj::Targeting_dyn();
HXLINE( 159)					if ((this->chosenAbilityPos != (int)-1)) {
HXLINE( 159)						int _g1 = (int)0;
HXDLIN( 159)						::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 159)						while((_g1 < _g11->length)){
HXLINE( 159)							::Dynamic o = _g11->__get(_g1);
HXDLIN( 159)							_g1 = (_g1 + (int)1);
HXDLIN( 159)							::battle::IModelObserver_obj::abDeselected(o,this->chosenAbilityPos);
            						}
            					}
HXLINE( 160)					{
HXLINE( 160)						int _g2 = (int)0;
HXDLIN( 160)						::Array< ::Dynamic> _g12 = this->observers;
HXDLIN( 160)						while((_g2 < _g12->length)){
HXLINE( 160)							::Dynamic o1 = _g12->__get(_g2);
HXDLIN( 160)							_g2 = (_g2 + (int)1);
HXDLIN( 160)							::battle::IModelObserver_obj::abSelected(o1,abilityPos);
            						}
            					}
HXLINE( 161)					this->chosenAbilityPos = abilityPos;
            				}
            				break;
            				case (int)1: {
HXLINE( 163)					int _g3 = (int)0;
HXDLIN( 163)					::Array< ::Dynamic> _g13 = this->observers;
HXDLIN( 163)					while((_g3 < _g13->length)){
HXLINE( 163)						::Dynamic o2 = _g13->__get(_g3);
HXDLIN( 163)						_g3 = (_g3 + (int)1);
HXDLIN( 163)						::battle::IModelObserver_obj::warn(o2,HX_("There is no ability in this slot",a0,93,e4,c9));
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 165)					int _g4 = (int)0;
HXDLIN( 165)					::Array< ::Dynamic> _g14 = this->observers;
HXDLIN( 165)					while((_g4 < _g14->length)){
HXLINE( 165)						::Dynamic o3 = _g14->__get(_g4);
HXDLIN( 165)						_g4 = (_g4 + (int)1);
HXDLIN( 165)						::battle::IModelObserver_obj::warn(o3,HX_("Not enough mana",4a,02,dc,b8));
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 167)					int _g5 = (int)0;
HXDLIN( 167)					::Array< ::Dynamic> _g15 = this->observers;
HXDLIN( 167)					while((_g5 < _g15->length)){
HXLINE( 167)						::Dynamic o4 = _g15->__get(_g5);
HXDLIN( 167)						_g5 = (_g5 + (int)1);
HXDLIN( 167)						::battle::IModelObserver_obj::warn(o4,HX_("This ability is currently on cooldown",14,7f,21,9f));
            					}
            				}
            				break;
            				case (int)4: {
HXLINE( 169)					int _g6 = (int)0;
HXDLIN( 169)					::Array< ::Dynamic> _g16 = this->observers;
HXDLIN( 169)					while((_g6 < _g16->length)){
HXLINE( 169)						::Dynamic o5 = _g16->__get(_g6);
HXDLIN( 169)						_g6 = (_g6 + (int)1);
HXDLIN( 169)						::battle::IModelObserver_obj::warn(o5,HX_("This ability is passive, you can't use it",85,c9,df,fe));
            					}
            				}
            				break;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,choose,(void))

void Model_obj::targetAndUse( ::battle::_hx_struct::UnitCoords targetCoords){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_175_targetAndUse)
HXDLIN( 175)		 ::battle::TargetResult _g = this->checkTarget(targetCoords,this->chosenAbilityPos);
HXDLIN( 175)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)0: {
HXLINE( 178)				this->inputMode = ::battle::enums::InputMode_obj::None_dyn();
HXLINE( 180)				{
HXLINE( 180)					int _g1 = (int)0;
HXDLIN( 180)					::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 180)					while((_g1 < _g11->length)){
HXLINE( 180)						::Dynamic o = _g11->__get(_g1);
HXDLIN( 180)						_g1 = (_g1 + (int)1);
HXDLIN( 180)						::battle::IModelObserver_obj::abDeselected(o,this->chosenAbilityPos);
            					}
            				}
HXLINE( 182)				 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::player();
HXDLIN( 182)				this->setUA(targetCoords,_hx_tmp,Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(this->chosenAbilityPos));
HXLINE( 183)				this->useAbility();
            			}
            			break;
            			case (int)1: {
HXLINE( 185)				this->inputMode = ::battle::enums::InputMode_obj::Choosing_dyn();
HXLINE( 187)				{
HXLINE( 187)					int _g2 = (int)0;
HXDLIN( 187)					::Array< ::Dynamic> _g12 = this->observers;
HXDLIN( 187)					while((_g2 < _g12->length)){
HXLINE( 187)						::Dynamic o1 = _g12->__get(_g2);
HXDLIN( 187)						_g2 = (_g2 + (int)1);
HXLINE( 189)						::battle::IModelObserver_obj::warn(o1,HX_("Chosen ability cannot be used on this target",b1,4d,aa,2a));
HXLINE( 190)						::battle::IModelObserver_obj::abDeselected(o1,this->chosenAbilityPos);
            					}
            				}
            			}
            			break;
            			case (int)2: case (int)3: {
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,targetAndUse,(void))

void Model_obj::useAbility(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_203_useAbility)
HXDLIN( 203)		int _g = this->UAiterator++;
HXDLIN( 203)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 206)				this->changeMana(this->UAcaster,this->UAcaster,-(this->UAability->manacost),::battle::enums::Source_obj::God_dyn());
HXLINE( 207)				 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 207)				::String _hx_tmp1 = (this->getUnits()->get(this->UAcaster).StaticCast<  ::battle::Unit >()->name + HX_(" now has ",f0,56,fb,3f));
HXDLIN( 207)				::String _hx_tmp2 = ((_hx_tmp1 + this->getUnits()->get(this->UAcaster).StaticCast<  ::battle::Unit >()->manaPool->value) + HX_(" mana",a7,cc,28,b5));
HXDLIN( 207)				_hx_tmp(_hx_tmp2,hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),207,HX_("battle.Model",d3,ab,e0,43),HX_("useAbility",23,84,14,b0)));
HXLINE( 208)				this->UAability->putOnCooldown();
HXLINE( 210)				this->continuePoint = this->useAbility_dyn();
HXLINE( 211)				{
HXLINE( 211)					int _g1 = (int)0;
HXDLIN( 211)					::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 211)					while((_g1 < _g11->length)){
HXLINE( 211)						::Dynamic o = _g11->__get(_g1);
HXDLIN( 211)						_g1 = (_g1 + (int)1);
HXDLIN( 211)						::battle::IModelObserver_obj::abThrown(o,this->UAtarget,this->UAcaster,this->UAability->id,this->UAability->strikeType,this->UAability->element);
            					}
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 213)				 ::battle::Unit target;
HXLINE( 214)				if (this->UAability->aoe) {
HXLINE( 216)					target = Dynamic( this->units->allied(this->UAtarget)->__get(this->AOECounter)).StaticCast<  ::battle::Unit >();
HXLINE( 217)					this->AOECounter++;
HXLINE( 218)					int _hx_tmp3 = this->AOECounter;
HXDLIN( 218)					if ((_hx_tmp3 < this->units->allied(this->UAtarget)->get_length())) {
HXLINE( 219)						this->UAiterator--;
            					}
            				}
            				else {
HXLINE( 222)					target = this->units->get(this->UAtarget).StaticCast<  ::battle::Unit >();
            				}
HXLINE( 224)				 ::battle::Unit _hx_tmp4 = this->units->get(this->UAcaster).StaticCast<  ::battle::Unit >();
HXDLIN( 224)				if (::battle::Utils_obj::flipMiss(target,_hx_tmp4,this->UAability)) {
HXLINE( 226)					 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 226)					::String _hx_tmp6 = (this->units->get(this->UAcaster).StaticCast<  ::battle::Unit >()->name + HX_(" -> ",6f,2f,49,15));
HXDLIN( 226)					_hx_tmp5(((_hx_tmp6 + target->name) + HX_(": Miss!",1f,2d,e2,d2)),hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),226,HX_("battle.Model",d3,ab,e0,43),HX_("useAbility",23,84,14,b0)));
HXLINE( 227)					{
HXLINE( 227)						int _g2 = (int)0;
HXDLIN( 227)						::Array< ::Dynamic> _g12 = this->observers;
HXDLIN( 227)						while((_g2 < _g12->length)){
HXLINE( 227)							::Dynamic o1 = _g12->__get(_g2);
HXDLIN( 227)							_g2 = (_g2 + (int)1);
HXDLIN( 227)							 ::battle::_hx_struct::UnitCoords _hx_tmp7 = ::battle::_hx_struct::UnitCoords_obj::get(target);
HXDLIN( 227)							::battle::IModelObserver_obj::miss(o1,_hx_tmp7,this->UAability->element);
            						}
            					}
            				}
            				else {
HXLINE( 230)					 ::ID _hx_tmp8 = this->UAability->id;
HXDLIN( 230)					 ::battle::_hx_struct::UnitCoords _hx_tmp9 = ::battle::_hx_struct::UnitCoords_obj::get(target);
HXDLIN( 230)					::battle::data::Abilities_obj::useAbility(_hx_tmp8,_hx_tmp9,this->UAcaster,this->UAability->element);
            				}
HXLINE( 232)				this->continuePoint = this->useAbility_dyn();
HXLINE( 233)				{
HXLINE( 233)					int _g3 = (int)0;
HXDLIN( 233)					::Array< ::Dynamic> _g13 = this->observers;
HXDLIN( 233)					while((_g3 < _g13->length)){
HXLINE( 233)						::Dynamic o2 = _g13->__get(_g3);
HXDLIN( 233)						_g3 = (_g3 + (int)1);
HXDLIN( 233)						 ::battle::_hx_struct::UnitCoords _hx_tmp10 = ::battle::_hx_struct::UnitCoords_obj::get(target);
HXDLIN( 233)						::battle::IModelObserver_obj::abStriked(o2,_hx_tmp10,this->UAcaster,this->UAability->id,this->UAability->strikeType,this->UAability->element);
            					}
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 235)				this->postTurnProcess(this->UAcaster);
            			}
            			break;
            			default:{
HXLINE( 237)				this->UAiterator = (int)0;
HXLINE( 238)				if (this->UAability->aoe) {
HXLINE( 239)					this->AOECounter = (int)0;
            				}
HXLINE( 240)				this->useAbility();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,useAbility,(void))

void Model_obj::setUA( ::battle::_hx_struct::UnitCoords target, ::battle::_hx_struct::UnitCoords caster, ::battle::Active ability){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_245_setUA)
HXLINE( 246)		this->UAtarget = target;
HXLINE( 247)		this->UAcaster = caster;
HXLINE( 248)		this->UAability = ability;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Model_obj,setUA,(void))

void Model_obj::clearUA(){
            	HX_GC_STACKFRAME(&_hx_pos_653930ec9597c981_252_clearUA)
HXLINE( 253)		this->UAtarget = ::battle::_hx_struct::UnitCoords_obj::nullC();
HXLINE( 254)		this->UAcaster = ::battle::_hx_struct::UnitCoords_obj::nullC();
HXLINE( 255)		this->UAability =  ::battle::Active_obj::__alloc( HX_CTX ,::ID_obj::NullID_dyn());
HXLINE( 256)		this->UAiterator = (int)0;
HXLINE( 257)		this->AOECounter = (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,clearUA,(void))

void Model_obj::alacrityIncrement(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_265_alacrityIncrement)
HXLINE( 266)		{
HXLINE( 266)			int _g = (int)0;
HXDLIN( 266)			::Array< ::Dynamic> _g1 = this->units->get_both();
HXDLIN( 266)			while((_g < _g1->length)){
HXLINE( 266)				 ::battle::Unit unit = _g1->__get(_g).StaticCast<  ::battle::Unit >();
HXDLIN( 266)				_g = (_g + (int)1);
HXLINE( 267)				if (this->checkAlive(::Array_obj< ::Dynamic>::__new(1)->init(0,unit))) {
HXLINE( 269)					 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::get(unit);
HXDLIN( 269)					 ::battle::_hx_struct::UnitCoords _hx_tmp1 = ::battle::_hx_struct::UnitCoords_obj::get(unit);
HXDLIN( 269)					this->changeAlacrity(_hx_tmp,_hx_tmp1,this->getAlacrityGain(unit),::battle::enums::Source_obj::God_dyn());
HXLINE( 271)					if ((unit->alacrityPool->value == (int)100)) {
HXLINE( 272)						this->readyUnits->push(unit);
            					}
            				}
            			}
            		}
HXLINE( 275)		if (::Lambda_obj::empty(this->readyUnits)) {
HXLINE( 276)			this->alacrityIncrement();
            		}
            		else {
HXLINE( 279)			this->sortByFlow(this->readyUnits);
HXLINE( 280)			this->processReady();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,alacrityIncrement,(void))

void Model_obj::processReady(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_286_processReady)
HXDLIN( 286)		if (!(::Lambda_obj::empty(this->readyUnits))) {
HXLINE( 288)			 ::battle::Unit unit = this->readyUnits->__get((int)0).StaticCast<  ::battle::Unit >();
HXLINE( 289)			this->readyUnits->removeRange((int)0,(int)1);
HXLINE( 290)			 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::get(unit);
HXDLIN( 290)			this->changeAlacrity(_hx_tmp,::battle::_hx_struct::UnitCoords_obj::get(unit),(int)-100,::battle::enums::Source_obj::God_dyn());
HXLINE( 292)			bool _hx_tmp1;
HXDLIN( 292)			if (!(unit->isStunned())) {
HXLINE( 292)				_hx_tmp1 = this->checkAlive(::Array_obj< ::Dynamic>::__new(1)->init(0,unit));
            			}
            			else {
HXLINE( 292)				_hx_tmp1 = false;
            			}
HXDLIN( 292)			if (_hx_tmp1) {
HXLINE( 294)				bool _hx_tmp2;
HXDLIN( 294)				if (hx::IsEq( unit->team,::battle::enums::Team_obj::Left_dyn() )) {
HXLINE( 294)					_hx_tmp2 = (unit->position == (int)0);
            				}
            				else {
HXLINE( 294)					_hx_tmp2 = false;
            				}
HXDLIN( 294)				if (_hx_tmp2) {
HXLINE( 295)					this->inputMode = ::battle::enums::InputMode_obj::Choosing_dyn();
            				}
            				else {
HXLINE( 297)					this->botMakeTurn(unit);
            				}
            			}
            			else {
HXLINE( 300)				this->postTurnProcess(::battle::_hx_struct::UnitCoords_obj::get(unit));
            			}
            		}
            		else {
HXLINE( 303)			this->alacrityIncrement();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,processReady,(void))

void Model_obj::postTurnProcess( ::battle::_hx_struct::UnitCoords coords){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_307_postTurnProcess)
HXLINE( 308)		 ::battle::Unit unit = this->units->get(coords).StaticCast<  ::battle::Unit >();
HXLINE( 310)		if (!(this->bothTeamsAlive())) {
HXLINE( 312)			this->end(this->defineWinner());
HXLINE( 313)			return;
            		}
HXLINE( 316)		if (unit->isAlive()) {
HXLINE( 318)			{
HXLINE( 318)				int _g = (int)0;
HXDLIN( 318)				::Array< ::Dynamic> _g1 = this->observers;
HXDLIN( 318)				while((_g < _g1->length)){
HXLINE( 318)					::Dynamic o = _g1->__get(_g);
HXDLIN( 318)					_g = (_g + (int)1);
HXDLIN( 318)					::battle::IModelObserver_obj::preTick(o,unit);
            				}
            			}
HXLINE( 319)			unit->tick();
HXLINE( 320)			{
HXLINE( 320)				int _g2 = (int)0;
HXDLIN( 320)				::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 320)				while((_g2 < _g11->length)){
HXLINE( 320)					::Dynamic o1 = _g11->__get(_g2);
HXDLIN( 320)					_g2 = (_g2 + (int)1);
HXDLIN( 320)					::battle::IModelObserver_obj::tick(o1,unit);
            				}
            			}
            		}
HXLINE( 323)		if (!(this->bothTeamsAlive())) {
HXLINE( 325)			this->end(this->defineWinner());
HXLINE( 326)			return;
            		}
HXLINE( 329)		this->processReady();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,postTurnProcess,(void))

void Model_obj::botMakeTurn( ::battle::Unit bot){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_333_botMakeTurn)
HXLINE( 334)		 ::Dynamic decision = ::battle::data::Units_obj::decide(bot->id);
HXLINE( 336)		 ::battle::_hx_struct::UnitCoords decision1 = ( ( ::battle::_hx_struct::UnitCoords)(decision->__Field(HX_("target",51,f3,ec,86),hx::paccDynamic)) );
HXDLIN( 336)		 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::get(bot);
HXDLIN( 336)		this->setUA(decision1,_hx_tmp,bot->wheel->getActive(( (int)(decision->__Field(HX_("abilityNum",bc,1a,8b,b3),hx::paccDynamic)) )));
HXLINE( 337)		this->useAbility();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,botMakeTurn,(void))

Float Model_obj::getAlacrityGain( ::battle::Unit unit){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_341_getAlacrityGain)
HXLINE( 342)		Float sum = (int)0;
HXLINE( 343)		{
HXLINE( 343)			int _g = (int)0;
HXDLIN( 343)			::Array< ::Dynamic> _g1 = this->units->get_both();
HXDLIN( 343)			while((_g < _g1->length)){
HXLINE( 343)				 ::battle::Unit u = _g1->__get(_g).StaticCast<  ::battle::Unit >();
HXDLIN( 343)				_g = (_g + (int)1);
HXLINE( 344)				if (this->checkAlive(::Array_obj< ::Dynamic>::__new(1)->init(0,u))) {
HXLINE( 345)					sum = (sum + u->flow);
            				}
            			}
            		}
HXLINE( 347)		return ((Float)unit->flow / (Float)sum);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,getAlacrityGain,return )

void Model_obj::sortByFlow(::Array< ::Dynamic> array){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0,::Array< ::Dynamic>,array) HXARGC(2)
            		void _hx_run(int j1,int j2){
            			HX_STACKFRAME(&_hx_pos_653930ec9597c981_353_sortByFlow)
HXLINE( 354)			 ::battle::Unit t = array->__get(j1).StaticCast<  ::battle::Unit >();
HXLINE( 355)			array[j1] = array->__get(j2).StaticCast<  ::battle::Unit >();
HXLINE( 356)			array[j2] = t;
            		}
            		HX_END_LOCAL_FUNC2((void))

            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_351_sortByFlow)
HXLINE( 352)		 ::Dynamic swap =  ::Dynamic(new _hx_Closure_0(array));
HXLINE( 359)		{
HXLINE( 359)			int _g1 = (int)1;
HXDLIN( 359)			int _g = array->length;
HXDLIN( 359)			while((_g1 < _g)){
HXLINE( 359)				_g1 = (_g1 + (int)1);
HXDLIN( 359)				int i = (_g1 - (int)1);
HXLINE( 360)				{
HXLINE( 360)					int _g3 = i;
HXDLIN( 360)					int _g2 = array->length;
HXDLIN( 360)					while((_g3 < _g2)){
HXLINE( 360)						_g3 = (_g3 + (int)1);
HXDLIN( 360)						int j = (_g3 - (int)1);
HXLINE( 361)						if ((array->__get((j - (int)1)).StaticCast<  ::battle::Unit >()->flow < array->__get(j).StaticCast<  ::battle::Unit >()->flow)) {
HXLINE( 362)							swap((j - (int)1),j);
            						}
            						else {
HXLINE( 363)							if ((array->__get((j - (int)1)).StaticCast<  ::battle::Unit >()->flow == array->__get(j).StaticCast<  ::battle::Unit >()->flow)) {
HXLINE( 364)								if (::MathUtils_obj::flip()) {
HXLINE( 365)									swap((j - (int)1),j);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,sortByFlow,(void))

void Model_obj::end( ::battle::enums::Team winner){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_373_end)
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,end,(void))

 ::battle::enums::Team Model_obj::defineWinner(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_379_defineWinner)
HXDLIN( 379)		if (this->checkAlive(this->units->left)) {
HXLINE( 380)			return ::battle::enums::Team_obj::Left_dyn();
            		}
            		else {
HXLINE( 381)			if (this->checkAlive(this->units->right)) {
HXLINE( 382)				return ::battle::enums::Team_obj::Right_dyn();
            			}
            			else {
HXLINE( 384)				return null();
            			}
            		}
HXLINE( 379)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,defineWinner,return )

bool Model_obj::checkAlive(::Array< ::Dynamic> array){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_388_checkAlive)
HXLINE( 389)		{
HXLINE( 389)			int _g = (int)0;
HXDLIN( 389)			while((_g < array->length)){
HXLINE( 389)				 ::battle::Unit unit = array->__get(_g).StaticCast<  ::battle::Unit >();
HXDLIN( 389)				_g = (_g + (int)1);
HXLINE( 390)				if (unit->isAlive()) {
HXLINE( 391)					return true;
            				}
            			}
            		}
HXLINE( 392)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,checkAlive,return )

bool Model_obj::bothTeamsAlive(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_397_bothTeamsAlive)
HXDLIN( 397)		if (this->checkAlive(this->units->left)) {
HXDLIN( 397)			return this->checkAlive(this->units->right);
            		}
            		else {
HXDLIN( 397)			return false;
            		}
HXDLIN( 397)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,bothTeamsAlive,return )

void Model_obj::skipTurn(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_406_skipTurn)
HXDLIN( 406)		if (hx::IsNotEq( this->inputMode,::battle::enums::InputMode_obj::None_dyn() )) {
HXLINE( 408)			this->inputMode = ::battle::enums::InputMode_obj::None_dyn();
HXLINE( 409)			 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::player();
HXDLIN( 409)			this->changeAlacrity(_hx_tmp,::battle::_hx_struct::UnitCoords_obj::player(),(int)-100,::battle::enums::Source_obj::God_dyn());
HXLINE( 410)			this->postTurnProcess(::battle::_hx_struct::UnitCoords_obj::player());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,skipTurn,(void))

void Model_obj::quit(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_416_quit)
HXDLIN( 416)		this->end(::battle::enums::Team_obj::Right_dyn());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,quit,(void))

void Model_obj::printAbilityInfo(int num){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_420_printAbilityInfo)
HXLINE( 421)		 ::battle::Ability ab = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->get(num);
HXLINE( 422)		::String result = ((HX_("",00,00,00,00) + ::Std_obj::string(ab)) + HX_(".name \n",a3,4d,54,96));
HXDLIN( 422)		::String result1 = ((result + ::Std_obj::string(ab)) + HX_(".type \n",d2,07,12,d0));
HXDLIN( 422)		::String result2 = ((result1 + ::Std_obj::string(ab)) + HX_(".describition",91,be,ba,7b));
HXLINE( 423)		if (hx::IsEq( ab->type,::battle::enums::AbilityType_obj::Active_dyn() )) {
HXLINE( 425)			 ::battle::Active a = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(num);
HXLINE( 426)			int maxCD = ( (int)(::XMLUtils_obj::parseAbility(a->id,HX_("cooldown",ab,4b,a2,f9),(int)1)) );
HXLINE( 427)			::String targets;
HXDLIN( 427)			 ::battle::enums::AbilityTarget _g = a->possibleTarget;
HXDLIN( 427)			switch((int)(_hx_getEnumValueIndex(_g))){
            				case (int)0: {
HXLINE( 427)					targets = HX_("self",8c,8b,50,4c);
            				}
            				break;
            				case (int)1: {
HXLINE( 427)					targets = HX_("allies & self",10,92,5b,6f);
            				}
            				break;
            				case (int)2: {
HXLINE( 427)					targets = HX_("enemies",a6,68,0e,d3);
            				}
            				break;
            				case (int)3: {
HXLINE( 427)					targets = HX_("all targets",03,ba,3f,a0);
            				}
            				break;
            			}
HXLINE( 435)			::String result3 = ((HX_("\n\nCooldown: ",f1,7b,68,f0) + ::Std_obj::string(a)) + HX_(".cooldown/",36,74,c1,01));
HXDLIN( 435)			::String result4 = ((result3 + (maxCD - (int)1)) + HX_(", Manacost: ",8e,fd,0c,4d));
HXDLIN( 435)			result2 = (result2 + (((result4 + ::Std_obj::string(a)) + HX_(".manacost \nPossible targets: ",c5,f8,0c,da)) + targets));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,printAbilityInfo,(void))

void Model_obj::printUnitInfo( ::battle::_hx_struct::UnitCoords coords){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_446_printUnitInfo)
HXLINE( 447)		 ::battle::Unit unit = this->units->get(coords).StaticCast<  ::battle::Unit >();
HXLINE( 449)		::String buffString = HX_("",00,00,00,00);
HXLINE( 450)		{
HXLINE( 450)			int _g = (int)0;
HXDLIN( 450)			::Array< ::Dynamic> _g1 = unit->buffQueue->queue;
HXDLIN( 450)			while((_g < _g1->length)){
HXLINE( 450)				 ::battle::Buff buff = _g1->__get(_g).StaticCast<  ::battle::Buff >();
HXDLIN( 450)				_g = (_g + (int)1);
HXLINE( 452)				if ((buffString != HX_("",00,00,00,00))) {
HXLINE( 453)					buffString = (buffString + HX_(";\n",6f,33,00,00));
            				}
HXLINE( 454)				::String buffString1 = ((HX_("",00,00,00,00) + ::Std_obj::string(buff)) + HX_(".name (",c1,4d,54,96));
HXDLIN( 454)				::String buffString2 = ((buffString1 + ::Std_obj::string(buff)) + HX_(".duration), Element: ",47,0a,ce,e9));
HXDLIN( 454)				::String buffString3 = ((buffString2 + ::Std_obj::string(buff)) + HX_(".element \n",b8,7b,4c,55));
HXDLIN( 454)				buffString = (buffString + ((buffString3 + ::Std_obj::string(buff)) + HX_(".description",8e,bb,82,2f)));
            			}
            		}
HXLINE( 457)		::String result = (((HX_("",00,00,00,00) + ::Std_obj::string(unit)) + HX_(".name\n\nBuffs:\n",57,30,cb,91)) + buffString);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,printUnitInfo,(void))

void Model_obj::addObserver(::Dynamic obs){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_470_addObserver)
HXLINE( 471)		this->observers->push(obs);
HXLINE( 472)		this->responsesLeft++;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,addObserver,(void))

void Model_obj::respond(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_477_respond)
HXDLIN( 477)		if ((this->responsesLeft == (int)0)) {
HXLINE( 478)			::haxe::Log_obj::trace(HX_("WARN//Unexpected response",6a,65,bf,ea),hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),478,HX_("battle.Model",d3,ab,e0,43),HX_("respond",55,89,0b,68)));
            		}
            		else {
HXLINE( 479)			if ((--this->responsesLeft == (int)0)) {
HXLINE( 481)				::cpp::VirtualArray args = this->continueArgs;
HXLINE( 482)				this->continueArgs = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 483)				this->responsesLeft = this->observers->length;
HXLINE( 485)				::Reflect_obj::callMethod(this->continuePoint,this->continuePoint,args);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,respond,(void))

 ::battle::ChooseResult Model_obj::checkChoose(int abilityPos){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_494_checkChoose)
HXLINE( 495)		 ::battle::Ability ability = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->get(abilityPos);
HXLINE( 497)		bool _hx_tmp;
HXDLIN( 497)		if (hx::IsNotEq( ability->id,::ID_obj::EmptyAbility_dyn() )) {
HXLINE( 497)			_hx_tmp = hx::IsEq( ability->id,::ID_obj::LockAbility_dyn() );
            		}
            		else {
HXLINE( 497)			_hx_tmp = true;
            		}
HXDLIN( 497)		if (_hx_tmp) {
HXLINE( 498)			return ::battle::ChooseResult_obj::Empty_dyn();
            		}
HXLINE( 499)		if (hx::IsEq( ability->type,::battle::enums::AbilityType_obj::Passive_dyn() )) {
HXLINE( 500)			return ::battle::ChooseResult_obj::Passive_dyn();
            		}
HXLINE( 502)		 ::battle::Active activeAbility = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(abilityPos);
HXLINE( 504)		if ((activeAbility->_cooldown->value > (int)0)) {
HXLINE( 505)			return ::battle::ChooseResult_obj::Cooldown_dyn();
            		}
HXLINE( 506)		 ::battle::Unit _this = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >();
HXDLIN( 506)		int _this1 = _this->manaPool->value;
HXDLIN( 506)		if ((_this1 < _this->wheel->getActive(abilityPos)->manacost)) {
HXLINE( 507)			return ::battle::ChooseResult_obj::Manacost_dyn();
            		}
HXLINE( 509)		return ::battle::ChooseResult_obj::Ok_dyn();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,checkChoose,return )

 ::battle::TargetResult Model_obj::checkTarget( ::battle::_hx_struct::UnitCoords targetCoords,int abilityPos){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_513_checkTarget)
HXLINE( 514)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 515)		 ::battle::Active ability = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(abilityPos);
HXLINE( 517)		if (hx::IsNull( target )) {
HXLINE( 518)			return ::battle::TargetResult_obj::Nonexistent_dyn();
            		}
HXLINE( 519)		if ((target->hpPool->value == (int)0)) {
HXLINE( 520)			return ::battle::TargetResult_obj::Dead_dyn();
            		}
HXLINE( 521)		 ::battle::enums::UnitType relation = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->figureRelation(target);
HXDLIN( 521)		bool _hx_tmp;
HXDLIN( 521)		 ::battle::enums::AbilityTarget _g = ability->possibleTarget;
HXDLIN( 521)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)0: {
HXLINE( 521)				_hx_tmp = hx::IsEq( relation,::battle::enums::UnitType_obj::Self_dyn() );
            			}
            			break;
            			case (int)1: {
HXLINE( 521)				if (hx::IsNotEq( relation,::battle::enums::UnitType_obj::Ally_dyn() )) {
HXLINE( 521)					_hx_tmp = hx::IsEq( relation,::battle::enums::UnitType_obj::Self_dyn() );
            				}
            				else {
HXLINE( 521)					_hx_tmp = true;
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 521)				_hx_tmp = hx::IsEq( relation,::battle::enums::UnitType_obj::Enemy_dyn() );
            			}
            			break;
            			case (int)3: {
HXLINE( 521)				_hx_tmp = true;
            			}
            			break;
            		}
HXDLIN( 521)		if (!(_hx_tmp)) {
HXLINE( 522)			return ::battle::TargetResult_obj::Invalid_dyn();
            		}
HXLINE( 524)		return ::battle::TargetResult_obj::Ok_dyn();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Model_obj,checkTarget,return )

bool Model_obj::targetAvaibility( ::battle::_hx_struct::UnitCoords unit){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_529_targetAvaibility)
HXDLIN( 529)		if (::MathUtils_obj::inRange(this->chosenAbilityPos,(int)0,(int)7,null(),null())) {
HXLINE( 530)			return hx::IsEq( this->checkTarget(unit,this->chosenAbilityPos),::battle::TargetResult_obj::Ok_dyn() );
            		}
            		else {
HXLINE( 532)			return false;
            		}
HXLINE( 529)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,targetAvaibility,return )

void Model_obj::init(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_550_init)
HXLINE( 551)		::battle::data::Abilities_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 552)		::battle::data::Units_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 553)		::battle::data::Buffs_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 554)		::battle::data::Passives_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 555)		this->alacrityIncrement();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,init,(void))


hx::ObjectPtr< Model_obj > Model_obj::__new(::Array< ::Dynamic> allies,::Array< ::Dynamic> enemies) {
	hx::ObjectPtr< Model_obj > __this = new Model_obj();
	__this->__construct(allies,enemies);
	return __this;
}

hx::ObjectPtr< Model_obj > Model_obj::__alloc(hx::Ctx *_hx_ctx,::Array< ::Dynamic> allies,::Array< ::Dynamic> enemies) {
	Model_obj *__this = (Model_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Model_obj), true, "battle.Model"));
	*(void **)__this = Model_obj::_hx_vtable;
	__this->__construct(allies,enemies);
	return __this;
}

Model_obj::Model_obj()
{
}

void Model_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Model);
	HX_MARK_MEMBER_NAME(observers,"observers");
	HX_MARK_MEMBER_NAME(units,"units");
	HX_MARK_MEMBER_NAME(inputMode,"inputMode");
	HX_MARK_MEMBER_NAME(chosenAbilityPos,"chosenAbilityPos");
	HX_MARK_MEMBER_NAME(UAtarget,"UAtarget");
	HX_MARK_MEMBER_NAME(UAcaster,"UAcaster");
	HX_MARK_MEMBER_NAME(UAability,"UAability");
	HX_MARK_MEMBER_NAME(UAiterator,"UAiterator");
	HX_MARK_MEMBER_NAME(AOECounter,"AOECounter");
	HX_MARK_MEMBER_NAME(responsesLeft,"responsesLeft");
	HX_MARK_MEMBER_NAME(continuePoint,"continuePoint");
	HX_MARK_MEMBER_NAME(continueArgs,"continueArgs");
	HX_MARK_MEMBER_NAME(readyUnits,"readyUnits");
	HX_MARK_END_CLASS();
}

void Model_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(observers,"observers");
	HX_VISIT_MEMBER_NAME(units,"units");
	HX_VISIT_MEMBER_NAME(inputMode,"inputMode");
	HX_VISIT_MEMBER_NAME(chosenAbilityPos,"chosenAbilityPos");
	HX_VISIT_MEMBER_NAME(UAtarget,"UAtarget");
	HX_VISIT_MEMBER_NAME(UAcaster,"UAcaster");
	HX_VISIT_MEMBER_NAME(UAability,"UAability");
	HX_VISIT_MEMBER_NAME(UAiterator,"UAiterator");
	HX_VISIT_MEMBER_NAME(AOECounter,"AOECounter");
	HX_VISIT_MEMBER_NAME(responsesLeft,"responsesLeft");
	HX_VISIT_MEMBER_NAME(continuePoint,"continuePoint");
	HX_VISIT_MEMBER_NAME(continueArgs,"continueArgs");
	HX_VISIT_MEMBER_NAME(readyUnits,"readyUnits");
}

hx::Val Model_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return hx::Val( end_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"quit") ) { return hx::Val( quit_dyn() ); }
		if (HX_FIELD_EQ(inName,"init") ) { return hx::Val( init_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"units") ) { return hx::Val( units ); }
		if (HX_FIELD_EQ(inName,"setUA") ) { return hx::Val( setUA_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"choose") ) { return hx::Val( choose_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"clearUA") ) { return hx::Val( clearUA_dyn() ); }
		if (HX_FIELD_EQ(inName,"respond") ) { return hx::Val( respond_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"UAtarget") ) { return hx::Val( UAtarget ); }
		if (HX_FIELD_EQ(inName,"UAcaster") ) { return hx::Val( UAcaster ); }
		if (HX_FIELD_EQ(inName,"getUnits") ) { return hx::Val( getUnits_dyn() ); }
		if (HX_FIELD_EQ(inName,"changeHP") ) { return hx::Val( changeHP_dyn() ); }
		if (HX_FIELD_EQ(inName,"castBuff") ) { return hx::Val( castBuff_dyn() ); }
		if (HX_FIELD_EQ(inName,"skipTurn") ) { return hx::Val( skipTurn_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"observers") ) { return hx::Val( observers ); }
		if (HX_FIELD_EQ(inName,"inputMode") ) { return hx::Val( inputMode ); }
		if (HX_FIELD_EQ(inName,"UAability") ) { return hx::Val( UAability ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"UAiterator") ) { return hx::Val( UAiterator ); }
		if (HX_FIELD_EQ(inName,"AOECounter") ) { return hx::Val( AOECounter ); }
		if (HX_FIELD_EQ(inName,"readyUnits") ) { return hx::Val( readyUnits ); }
		if (HX_FIELD_EQ(inName,"changeMana") ) { return hx::Val( changeMana_dyn() ); }
		if (HX_FIELD_EQ(inName,"useAbility") ) { return hx::Val( useAbility_dyn() ); }
		if (HX_FIELD_EQ(inName,"sortByFlow") ) { return hx::Val( sortByFlow_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkAlive") ) { return hx::Val( checkAlive_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"botMakeTurn") ) { return hx::Val( botMakeTurn_dyn() ); }
		if (HX_FIELD_EQ(inName,"addObserver") ) { return hx::Val( addObserver_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkChoose") ) { return hx::Val( checkChoose_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkTarget") ) { return hx::Val( checkTarget_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"continueArgs") ) { return hx::Val( continueArgs ); }
		if (HX_FIELD_EQ(inName,"getInputMode") ) { return hx::Val( getInputMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"dispellBuffs") ) { return hx::Val( dispellBuffs_dyn() ); }
		if (HX_FIELD_EQ(inName,"targetAndUse") ) { return hx::Val( targetAndUse_dyn() ); }
		if (HX_FIELD_EQ(inName,"processReady") ) { return hx::Val( processReady_dyn() ); }
		if (HX_FIELD_EQ(inName,"defineWinner") ) { return hx::Val( defineWinner_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"responsesLeft") ) { return hx::Val( responsesLeft ); }
		if (HX_FIELD_EQ(inName,"continuePoint") ) { return hx::Val( continuePoint ); }
		if (HX_FIELD_EQ(inName,"printUnitInfo") ) { return hx::Val( printUnitInfo_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"changeAlacrity") ) { return hx::Val( changeAlacrity_dyn() ); }
		if (HX_FIELD_EQ(inName,"bothTeamsAlive") ) { return hx::Val( bothTeamsAlive_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"postTurnProcess") ) { return hx::Val( postTurnProcess_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAlacrityGain") ) { return hx::Val( getAlacrityGain_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"chosenAbilityPos") ) { return hx::Val( chosenAbilityPos ); }
		if (HX_FIELD_EQ(inName,"printAbilityInfo") ) { return hx::Val( printAbilityInfo_dyn() ); }
		if (HX_FIELD_EQ(inName,"targetAvaibility") ) { return hx::Val( targetAvaibility_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"alacrityIncrement") ) { return hx::Val( alacrityIncrement_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Model_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"units") ) { units=inValue.Cast<  ::battle::_hx_struct::UPair >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"UAtarget") ) { UAtarget=inValue.Cast<  ::battle::_hx_struct::UnitCoords >(); return inValue; }
		if (HX_FIELD_EQ(inName,"UAcaster") ) { UAcaster=inValue.Cast<  ::battle::_hx_struct::UnitCoords >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"observers") ) { observers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"inputMode") ) { inputMode=inValue.Cast<  ::battle::enums::InputMode >(); return inValue; }
		if (HX_FIELD_EQ(inName,"UAability") ) { UAability=inValue.Cast<  ::battle::Active >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"UAiterator") ) { UAiterator=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"AOECounter") ) { AOECounter=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"readyUnits") ) { readyUnits=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"continueArgs") ) { continueArgs=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"responsesLeft") ) { responsesLeft=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"continuePoint") ) { continuePoint=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"chosenAbilityPos") ) { chosenAbilityPos=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Model_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("observers","\x9d","\x57","\x26","\x5e"));
	outFields->push(HX_HCSTRING("units","\x6f","\x69","\xe7","\xa6"));
	outFields->push(HX_HCSTRING("inputMode","\x8d","\x90","\x8b","\x0f"));
	outFields->push(HX_HCSTRING("chosenAbilityPos","\x5c","\x48","\xce","\x46"));
	outFields->push(HX_HCSTRING("UAtarget","\x9d","\xfe","\x9f","\x13"));
	outFields->push(HX_HCSTRING("UAcaster","\x38","\xf0","\x41","\x48"));
	outFields->push(HX_HCSTRING("UAability","\xde","\x38","\x58","\x3d"));
	outFields->push(HX_HCSTRING("UAiterator","\x3a","\xc0","\x9f","\xfb"));
	outFields->push(HX_HCSTRING("AOECounter","\x25","\x70","\xab","\x40"));
	outFields->push(HX_HCSTRING("responsesLeft","\xf9","\x07","\xe4","\x88"));
	outFields->push(HX_HCSTRING("continuePoint","\x69","\x6e","\x8a","\xd2"));
	outFields->push(HX_HCSTRING("continueArgs","\x64","\x59","\x4c","\xf1"));
	outFields->push(HX_HCSTRING("readyUnits","\x0c","\xf2","\x2a","\x60"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Model_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< ::battle::IModelObserver >*/ ,(int)offsetof(Model_obj,observers),HX_HCSTRING("observers","\x9d","\x57","\x26","\x5e")},
	{hx::fsObject /*::battle::_hx_struct::UPair*/ ,(int)offsetof(Model_obj,units),HX_HCSTRING("units","\x6f","\x69","\xe7","\xa6")},
	{hx::fsObject /*::battle::enums::InputMode*/ ,(int)offsetof(Model_obj,inputMode),HX_HCSTRING("inputMode","\x8d","\x90","\x8b","\x0f")},
	{hx::fsInt,(int)offsetof(Model_obj,chosenAbilityPos),HX_HCSTRING("chosenAbilityPos","\x5c","\x48","\xce","\x46")},
	{hx::fsObject /*::battle::_hx_struct::UnitCoords*/ ,(int)offsetof(Model_obj,UAtarget),HX_HCSTRING("UAtarget","\x9d","\xfe","\x9f","\x13")},
	{hx::fsObject /*::battle::_hx_struct::UnitCoords*/ ,(int)offsetof(Model_obj,UAcaster),HX_HCSTRING("UAcaster","\x38","\xf0","\x41","\x48")},
	{hx::fsObject /*::battle::Active*/ ,(int)offsetof(Model_obj,UAability),HX_HCSTRING("UAability","\xde","\x38","\x58","\x3d")},
	{hx::fsInt,(int)offsetof(Model_obj,UAiterator),HX_HCSTRING("UAiterator","\x3a","\xc0","\x9f","\xfb")},
	{hx::fsInt,(int)offsetof(Model_obj,AOECounter),HX_HCSTRING("AOECounter","\x25","\x70","\xab","\x40")},
	{hx::fsInt,(int)offsetof(Model_obj,responsesLeft),HX_HCSTRING("responsesLeft","\xf9","\x07","\xe4","\x88")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Model_obj,continuePoint),HX_HCSTRING("continuePoint","\x69","\x6e","\x8a","\xd2")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(Model_obj,continueArgs),HX_HCSTRING("continueArgs","\x64","\x59","\x4c","\xf1")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Model_obj,readyUnits),HX_HCSTRING("readyUnits","\x0c","\xf2","\x2a","\x60")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Model_obj_sStaticStorageInfo = 0;
#endif

static ::String Model_obj_sMemberFields[] = {
	HX_HCSTRING("observers","\x9d","\x57","\x26","\x5e"),
	HX_HCSTRING("units","\x6f","\x69","\xe7","\xa6"),
	HX_HCSTRING("inputMode","\x8d","\x90","\x8b","\x0f"),
	HX_HCSTRING("chosenAbilityPos","\x5c","\x48","\xce","\x46"),
	HX_HCSTRING("UAtarget","\x9d","\xfe","\x9f","\x13"),
	HX_HCSTRING("UAcaster","\x38","\xf0","\x41","\x48"),
	HX_HCSTRING("UAability","\xde","\x38","\x58","\x3d"),
	HX_HCSTRING("UAiterator","\x3a","\xc0","\x9f","\xfb"),
	HX_HCSTRING("AOECounter","\x25","\x70","\xab","\x40"),
	HX_HCSTRING("responsesLeft","\xf9","\x07","\xe4","\x88"),
	HX_HCSTRING("continuePoint","\x69","\x6e","\x8a","\xd2"),
	HX_HCSTRING("continueArgs","\x64","\x59","\x4c","\xf1"),
	HX_HCSTRING("readyUnits","\x0c","\xf2","\x2a","\x60"),
	HX_HCSTRING("getUnits","\xf9","\x78","\xbe","\x06"),
	HX_HCSTRING("getInputMode","\x17","\x2d","\xe2","\x1e"),
	HX_HCSTRING("changeHP","\x78","\x0c","\x4e","\x66"),
	HX_HCSTRING("changeMana","\x17","\x72","\x9f","\x22"),
	HX_HCSTRING("changeAlacrity","\x99","\x67","\x5a","\xa5"),
	HX_HCSTRING("castBuff","\x32","\x20","\xa3","\xd1"),
	HX_HCSTRING("dispellBuffs","\x3d","\xb0","\xa8","\xcd"),
	HX_HCSTRING("choose","\xd7","\x5a","\xb4","\xc0"),
	HX_HCSTRING("targetAndUse","\xe1","\x43","\x90","\x1d"),
	HX_HCSTRING("useAbility","\x23","\x84","\x14","\xb0"),
	HX_HCSTRING("setUA","\x6e","\x92","\x2f","\x7a"),
	HX_HCSTRING("clearUA","\x19","\xf9","\x44","\xab"),
	HX_HCSTRING("alacrityIncrement","\xe6","\xb2","\x1b","\x86"),
	HX_HCSTRING("processReady","\x74","\x3b","\x6f","\xce"),
	HX_HCSTRING("postTurnProcess","\xf2","\xa7","\x40","\x24"),
	HX_HCSTRING("botMakeTurn","\xb2","\x39","\x28","\x68"),
	HX_HCSTRING("getAlacrityGain","\xde","\xd4","\xb9","\x9c"),
	HX_HCSTRING("sortByFlow","\x63","\x47","\xf2","\x65"),
	HX_HCSTRING("end","\xdb","\x03","\x4d","\x00"),
	HX_HCSTRING("defineWinner","\x5a","\x70","\x04","\x2c"),
	HX_HCSTRING("checkAlive","\xe5","\x65","\x81","\x31"),
	HX_HCSTRING("bothTeamsAlive","\x98","\x76","\x21","\x4c"),
	HX_HCSTRING("skipTurn","\x9c","\xd9","\x5a","\xc3"),
	HX_HCSTRING("quit","\xcf","\x3f","\x0a","\x4b"),
	HX_HCSTRING("printAbilityInfo","\x0b","\x68","\xb5","\x60"),
	HX_HCSTRING("printUnitInfo","\x5f","\x4a","\x94","\xae"),
	HX_HCSTRING("addObserver","\x57","\x73","\xaa","\x57"),
	HX_HCSTRING("respond","\x55","\x89","\x0b","\x68"),
	HX_HCSTRING("checkChoose","\xbf","\x2d","\xc6","\xa2"),
	HX_HCSTRING("checkTarget","\x39","\xc6","\xfe","\x68"),
	HX_HCSTRING("targetAvaibility","\x17","\xce","\x73","\x80"),
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	::String(null()) };

static void Model_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Model_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Model_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Model_obj::__mClass,"__mClass");
};

#endif

hx::Class Model_obj::__mClass;

void Model_obj::__register()
{
	hx::Object *dummy = new Model_obj;
	Model_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("battle.Model","\xd3","\xab","\xe0","\x43");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Model_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Model_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Model_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Model_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Model_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Model_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace battle
