// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Element
#include <Element.h>
#endif
#ifndef INCLUDED_ID
#include <ID.h>
#endif
#ifndef INCLUDED_Lambda
#include <Lambda.h>
#endif
#ifndef INCLUDED_MathUtils
#include <MathUtils.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_battle_Ability
#include <battle/Ability.h>
#endif
#ifndef INCLUDED_battle_Active
#include <battle/Active.h>
#endif
#ifndef INCLUDED_battle_Buff
#include <battle/Buff.h>
#endif
#ifndef INCLUDED_battle_ChooseResult
#include <battle/ChooseResult.h>
#endif
#ifndef INCLUDED_battle_IModelObserver
#include <battle/IModelObserver.h>
#endif
#ifndef INCLUDED_battle_IMutableModel
#include <battle/IMutableModel.h>
#endif
#ifndef INCLUDED_battle_IObservableModel
#include <battle/IObservableModel.h>
#endif
#ifndef INCLUDED_battle_ISimpleModel
#include <battle/ISimpleModel.h>
#endif
#ifndef INCLUDED_battle_Model
#include <battle/Model.h>
#endif
#ifndef INCLUDED_battle_TargetResult
#include <battle/TargetResult.h>
#endif
#ifndef INCLUDED_battle_Unit
#include <battle/Unit.h>
#endif
#ifndef INCLUDED_battle_Utils
#include <battle/Utils.h>
#endif
#ifndef INCLUDED_battle_data_Abilities
#include <battle/data/Abilities.h>
#endif
#ifndef INCLUDED_battle_data_Buffs
#include <battle/data/Buffs.h>
#endif
#ifndef INCLUDED_battle_data_Passives
#include <battle/data/Passives.h>
#endif
#ifndef INCLUDED_battle_data_Units
#include <battle/data/Units.h>
#endif
#ifndef INCLUDED_battle_enums_AbilityTarget
#include <battle/enums/AbilityTarget.h>
#endif
#ifndef INCLUDED_battle_enums_AbilityType
#include <battle/enums/AbilityType.h>
#endif
#ifndef INCLUDED_battle_enums_InputMode
#include <battle/enums/InputMode.h>
#endif
#ifndef INCLUDED_battle_enums_Source
#include <battle/enums/Source.h>
#endif
#ifndef INCLUDED_battle_enums_StrikeType
#include <battle/enums/StrikeType.h>
#endif
#ifndef INCLUDED_battle_enums_Team
#include <battle/enums/Team.h>
#endif
#ifndef INCLUDED_battle_enums_UnitType
#include <battle/enums/UnitType.h>
#endif
#ifndef INCLUDED_battle_struct_BuffQueue
#include <battle/struct/BuffQueue.h>
#endif
#ifndef INCLUDED_battle_struct_Countdown
#include <battle/struct/Countdown.h>
#endif
#ifndef INCLUDED_battle_struct_FloatPool
#include <battle/struct/FloatPool.h>
#endif
#ifndef INCLUDED_battle_struct_Pool
#include <battle/struct/Pool.h>
#endif
#ifndef INCLUDED_battle_struct_UPair
#include <battle/struct/UPair.h>
#endif
#ifndef INCLUDED_battle_struct_UnitCoords
#include <battle/struct/UnitCoords.h>
#endif
#ifndef INCLUDED_battle_struct_Wheel
#include <battle/struct/Wheel.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_653930ec9597c981_479_new,"battle.Model","new",0xd55a3245,"battle.Model.new","battle/Model.hx",479,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_67_getUnits,"battle.Model","getUnits",0x69b218f4,"battle.Model.getUnits","battle/Model.hx",67,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_72_getInputMode,"battle.Model","getInputMode",0xb324e692,"battle.Model.getInputMode","battle/Model.hx",72,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_80_changeHP,"battle.Model","changeHP",0xc941ac73,"battle.Model.changeHP","battle/Model.hx",80,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_107_changeMana,"battle.Model","changeMana",0xe1b746d2,"battle.Model.changeMana","battle/Model.hx",107,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_117_changeAlacrity,"battle.Model","changeAlacrity",0xdadab5d4,"battle.Model.changeAlacrity","battle/Model.hx",117,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_127_castBuff,"battle.Model","castBuff",0x3496c02d,"battle.Model.castBuff","battle/Model.hx",127,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_140_dispellBuffs,"battle.Model","dispellBuffs",0x61eb69b8,"battle.Model.dispellBuffs","battle/Model.hx",140,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_153_choose,"battle.Model","choose",0x087e7612,"battle.Model.choose","battle/Model.hx",153,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_176_targetAndUse,"battle.Model","targetAndUse",0xb1d2fd5c,"battle.Model.targetAndUse","battle/Model.hx",176,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_204_useAbility,"battle.Model","useAbility",0x6f2c58de,"battle.Model.useAbility","battle/Model.hx",204,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_246_setUA,"battle.Model","setUA",0x66fdf793,"battle.Model.setUA","battle/Model.hx",246,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_253_clearUA,"battle.Model","clearUA",0x3452b17e,"battle.Model.clearUA","battle/Model.hx",253,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_267_alacrityIncrement,"battle.Model","alacrityIncrement",0x763fbb8b,"battle.Model.alacrityIncrement","battle/Model.hx",267,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_266_alacrityIncrement,"battle.Model","alacrityIncrement",0x763fbb8b,"battle.Model.alacrityIncrement","battle/Model.hx",266,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_290_processReady,"battle.Model","processReady",0x62b1f4ef,"battle.Model.processReady","battle/Model.hx",290,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_310_postTurnProcess,"battle.Model","postTurnProcess",0xbf04cd57,"battle.Model.postTurnProcess","battle/Model.hx",310,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_336_botMakeTurn,"battle.Model","botMakeTurn",0xddea8897,"battle.Model.botMakeTurn","battle/Model.hx",336,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_344_getAlacrityGain,"battle.Model","getAlacrityGain",0x377dfa43,"battle.Model.getAlacrityGain","battle/Model.hx",344,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_358_end,"battle.Model","end",0xd55365c0,"battle.Model.end","battle/Model.hx",358,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_364_defineWinner,"battle.Model","defineWinner",0xc04729d5,"battle.Model.defineWinner","battle/Model.hx",364,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_373_checkAlive,"battle.Model","checkAlive",0xf0993aa0,"battle.Model.checkAlive","battle/Model.hx",373,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_382_bothTeamsAlive,"battle.Model","bothTeamsAlive",0x81a1c4d3,"battle.Model.bothTeamsAlive","battle/Model.hx",382,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_391_skipTurn,"battle.Model","skipTurn",0x264e7997,"battle.Model.skipTurn","battle/Model.hx",391,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_401_quit,"battle.Model","quit",0xdb99864a,"battle.Model.quit","battle/Model.hx",401,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_409_addObserver,"battle.Model","addObserver",0xcd6cc23c,"battle.Model.addObserver","battle/Model.hx",409,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_416_respond,"battle.Model","respond",0xf11941ba,"battle.Model.respond","battle/Model.hx",416,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_435_checkChoose,"battle.Model","checkChoose",0x18887ca4,"battle.Model.checkChoose","battle/Model.hx",435,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_454_checkTarget,"battle.Model","checkTarget",0xdec1151e,"battle.Model.checkTarget","battle/Model.hx",454,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_470_targetAvaibility,"battle.Model","targetAvaibility",0x51506112,"battle.Model.targetAvaibility","battle/Model.hx",470,0xce28e5cc)
HX_LOCAL_STACK_FRAME(_hx_pos_653930ec9597c981_491_init,"battle.Model","init",0xd64a818b,"battle.Model.init","battle/Model.hx",491,0xce28e5cc)
namespace battle{

void Model_obj::__construct(::Array< ::Dynamic> allies,::Array< ::Dynamic> enemies){
            	HX_GC_STACKFRAME(&_hx_pos_653930ec9597c981_479_new)
HXLINE( 480)		this->units =  ::battle::_hx_struct::UPair_obj::__alloc( HX_CTX ,allies,enemies);
HXLINE( 481)		this->readyUnits = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 482)		this->chosenAbilityPos = (int)-1;
HXLINE( 483)		this->inputMode = ::battle::enums::InputMode_obj::None_dyn();
HXLINE( 484)		this->observers = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 485)		this->responsesLeft = (int)0;
HXLINE( 486)		this->continueArgs = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 487)		this->clearUA();
            	}

Dynamic Model_obj::__CreateEmpty() { return new Model_obj; }

void *Model_obj::_hx_vtable = 0;

Dynamic Model_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Model_obj > _hx_result = new Model_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Model_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x05fd5cc9;
}

static ::battle::IMutableModel_obj _hx_battle_Model__hx_battle_IMutableModel= {
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,int, ::Element, ::battle::enums::Source))&::battle::Model_obj::changeHP,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,int, ::battle::enums::Source))&::battle::Model_obj::changeMana,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,Float, ::battle::enums::Source))&::battle::Model_obj::changeAlacrity,
	( void (hx::Object::*)( ::ID, ::battle::_hx_struct::UnitCoords, ::battle::_hx_struct::UnitCoords,int))&::battle::Model_obj::castBuff,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords,::Array< ::Dynamic>, ::Dynamic))&::battle::Model_obj::dispellBuffs,
	(  ::battle::_hx_struct::UPair (hx::Object::*)())&::battle::Model_obj::getUnits,
};

static ::battle::IObservableModel_obj _hx_battle_Model__hx_battle_IObservableModel= {
	(  ::battle::enums::InputMode (hx::Object::*)())&::battle::Model_obj::getInputMode,
	( bool (hx::Object::*)( ::battle::_hx_struct::UnitCoords))&::battle::Model_obj::targetAvaibility,
	( void (hx::Object::*)(int))&::battle::Model_obj::choose,
	( void (hx::Object::*)( ::battle::_hx_struct::UnitCoords))&::battle::Model_obj::targetAndUse,
	( void (hx::Object::*)())&::battle::Model_obj::skipTurn,
	( void (hx::Object::*)())&::battle::Model_obj::quit,
	( void (hx::Object::*)())&::battle::Model_obj::respond,
};

static ::battle::ISimpleModel_obj _hx_battle_Model__hx_battle_ISimpleModel= {
	(  ::battle::_hx_struct::UPair (hx::Object::*)())&::battle::Model_obj::getUnits,
	( void (hx::Object::*)())&::battle::Model_obj::respond,
};

void *Model_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x315d9f14: return &_hx_battle_Model__hx_battle_IMutableModel;
		case (int)0xf5b152d5: return &_hx_battle_Model__hx_battle_IObservableModel;
		case (int)0x4a70be46: return &_hx_battle_Model__hx_battle_ISimpleModel;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

 ::battle::_hx_struct::UPair Model_obj::getUnits(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_67_getUnits)
HXDLIN(  67)		return this->units;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,getUnits,return )

 ::battle::enums::InputMode Model_obj::getInputMode(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_72_getInputMode)
HXDLIN(  72)		return this->inputMode;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,getInputMode,return )

void Model_obj::changeHP( ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,int dhp, ::Element element, ::battle::enums::Source source){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_80_changeHP)
HXLINE(  81)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE(  82)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE(  83)		bool crit = false;
HXLINE(  85)		if (hx::IsNotEq( source,::battle::enums::Source_obj::God_dyn() )) {
HXLINE(  87)			dhp = ::battle::Utils_obj::calcBoost(dhp,caster,target);
HXLINE(  89)			if (::battle::Utils_obj::flipCrit(caster)) {
HXLINE(  91)				crit = true;
HXLINE(  92)				dhp = ::battle::Utils_obj::calcCrit(dhp,caster);
            			}
            		}
HXLINE(  95)		 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  95)		::String _hx_tmp1;
HXDLIN(  95)		if (crit) {
HXLINE(  95)			_hx_tmp1 = HX_("!",21,00,00,00);
            		}
            		else {
HXLINE(  95)			_hx_tmp1 = HX_("",00,00,00,00);
            		}
HXDLIN(  95)		_hx_tmp((((((caster->name + HX_(" deals ",19,8e,47,96)) + -(dhp)) + _hx_tmp1) + HX_(" damage to ",34,96,33,ae)) + target->name),hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),95,HX_("battle.Model",d3,ab,e0,43),HX_("changeHP",78,0c,4e,66)));
HXLINE(  96)		{
HXLINE(  96)			 ::battle::_hx_struct::Pool _g = target->hpPool;
HXDLIN(  96)			_g->set_value((_g->value + dhp));
            		}
HXLINE(  97)		 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN(  97)		::String _hx_tmp3 = (target->name + HX_(" is still alive: ",25,5e,7b,46));
HXDLIN(  97)		::String _hx_tmp4 = (_hx_tmp3 + ::Std_obj::string(target->isAlive()));
HXDLIN(  97)		_hx_tmp2(_hx_tmp4,hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),97,HX_("battle.Model",d3,ab,e0,43),HX_("changeHP",78,0c,4e,66)));
HXLINE(  98)		{
HXLINE(  98)			int _g1 = (int)0;
HXDLIN(  98)			::Array< ::Dynamic> _g11 = this->observers;
HXDLIN(  98)			while((_g1 < _g11->length)){
HXLINE(  98)				::Dynamic o = _g11->__get(_g1);
HXDLIN(  98)				_g1 = (_g1 + (int)1);
HXLINE( 100)				::battle::IModelObserver_obj::hpUpdate(o,target,caster,dhp,element,crit,source);
HXLINE( 101)				if (!(target->isAlive())) {
HXLINE( 102)					::battle::IModelObserver_obj::death(o,targetCoords);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Model_obj,changeHP,(void))

void Model_obj::changeMana( ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,int dmana, ::battle::enums::Source source){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_107_changeMana)
HXLINE( 108)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 109)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE( 111)		{
HXLINE( 111)			 ::battle::_hx_struct::Pool _g = target->manaPool;
HXDLIN( 111)			_g->set_value((_g->value + dmana));
            		}
HXLINE( 113)		{
HXLINE( 113)			int _g1 = (int)0;
HXDLIN( 113)			::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 113)			while((_g1 < _g11->length)){
HXLINE( 113)				::Dynamic o = _g11->__get(_g1);
HXDLIN( 113)				_g1 = (_g1 + (int)1);
HXDLIN( 113)				::battle::IModelObserver_obj::manaUpdate(o,target,dmana,source);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Model_obj,changeMana,(void))

void Model_obj::changeAlacrity( ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,Float dalac, ::battle::enums::Source source){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_117_changeAlacrity)
HXLINE( 118)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 119)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE( 121)		{
HXLINE( 121)			 ::battle::_hx_struct::FloatPool _g = target->alacrityPool;
HXDLIN( 121)			_g->set_value((_g->value + dalac));
            		}
HXLINE( 123)		{
HXLINE( 123)			int _g1 = (int)0;
HXDLIN( 123)			::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 123)			while((_g1 < _g11->length)){
HXLINE( 123)				::Dynamic o = _g11->__get(_g1);
HXDLIN( 123)				_g1 = (_g1 + (int)1);
HXDLIN( 123)				::battle::IModelObserver_obj::alacUpdate(o,target,dalac,source);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Model_obj,changeAlacrity,(void))

void Model_obj::castBuff( ::ID id, ::battle::_hx_struct::UnitCoords targetCoords, ::battle::_hx_struct::UnitCoords casterCoords,int duration){
            	HX_GC_STACKFRAME(&_hx_pos_653930ec9597c981_127_castBuff)
HXLINE( 128)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 129)		 ::battle::Unit caster = this->units->get(casterCoords).StaticCast<  ::battle::Unit >();
HXLINE( 131)		if (targetCoords->equals(casterCoords)) {
HXLINE( 132)			duration = (duration + (int)1);
            		}
HXLINE( 134)		 ::battle::_hx_struct::BuffQueue target1 = target->buffQueue;
HXDLIN( 134)		target1->addBuff( ::battle::Buff_obj::__alloc( HX_CTX ,id,duration,targetCoords,casterCoords));
HXLINE( 136)		{
HXLINE( 136)			int _g = (int)0;
HXDLIN( 136)			::Array< ::Dynamic> _g1 = this->observers;
HXDLIN( 136)			while((_g < _g1->length)){
HXLINE( 136)				::Dynamic o = _g1->__get(_g);
HXDLIN( 136)				_g = (_g + (int)1);
HXDLIN( 136)				::battle::IModelObserver_obj::buffQueueUpdate(o,targetCoords,target->buffQueue->queue);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Model_obj,castBuff,(void))

void Model_obj::dispellBuffs( ::battle::_hx_struct::UnitCoords targetCoords,::Array< ::Dynamic> elements, ::Dynamic __o_count){
 ::Dynamic count = __o_count.Default(-1);
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_140_dispellBuffs)
HXLINE( 141)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 143)		target->buffQueue->dispellByElement(elements,count);
HXLINE( 145)		{
HXLINE( 145)			int _g = (int)0;
HXDLIN( 145)			::Array< ::Dynamic> _g1 = this->observers;
HXDLIN( 145)			while((_g < _g1->length)){
HXLINE( 145)				::Dynamic o = _g1->__get(_g);
HXDLIN( 145)				_g = (_g + (int)1);
HXDLIN( 145)				::battle::IModelObserver_obj::buffQueueUpdate(o,targetCoords,target->buffQueue->queue);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Model_obj,dispellBuffs,(void))

void Model_obj::choose(int abilityPos){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_153_choose)
HXLINE( 154)		 ::battle::Ability ability = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->get(abilityPos);
HXLINE( 156)		{
HXLINE( 156)			 ::battle::ChooseResult _g = this->checkChoose(abilityPos);
HXDLIN( 156)			switch((int)(_hx_getEnumValueIndex(_g))){
            				case (int)0: {
HXLINE( 159)					this->inputMode = ::battle::enums::InputMode_obj::Targeting_dyn();
HXLINE( 160)					if ((this->chosenAbilityPos != (int)-1)) {
HXLINE( 160)						int _g1 = (int)0;
HXDLIN( 160)						::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 160)						while((_g1 < _g11->length)){
HXLINE( 160)							::Dynamic o = _g11->__get(_g1);
HXDLIN( 160)							_g1 = (_g1 + (int)1);
HXDLIN( 160)							::battle::IModelObserver_obj::abDeselected(o,this->chosenAbilityPos);
            						}
            					}
HXLINE( 161)					{
HXLINE( 161)						int _g2 = (int)0;
HXDLIN( 161)						::Array< ::Dynamic> _g12 = this->observers;
HXDLIN( 161)						while((_g2 < _g12->length)){
HXLINE( 161)							::Dynamic o1 = _g12->__get(_g2);
HXDLIN( 161)							_g2 = (_g2 + (int)1);
HXDLIN( 161)							::battle::IModelObserver_obj::abSelected(o1,abilityPos);
            						}
            					}
HXLINE( 162)					this->chosenAbilityPos = abilityPos;
            				}
            				break;
            				case (int)1: {
HXLINE( 164)					int _g3 = (int)0;
HXDLIN( 164)					::Array< ::Dynamic> _g13 = this->observers;
HXDLIN( 164)					while((_g3 < _g13->length)){
HXLINE( 164)						::Dynamic o2 = _g13->__get(_g3);
HXDLIN( 164)						_g3 = (_g3 + (int)1);
HXDLIN( 164)						::battle::IModelObserver_obj::warn(o2,HX_("There is no ability in this slot",a0,93,e4,c9));
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 166)					int _g4 = (int)0;
HXDLIN( 166)					::Array< ::Dynamic> _g14 = this->observers;
HXDLIN( 166)					while((_g4 < _g14->length)){
HXLINE( 166)						::Dynamic o3 = _g14->__get(_g4);
HXDLIN( 166)						_g4 = (_g4 + (int)1);
HXDLIN( 166)						::battle::IModelObserver_obj::warn(o3,HX_("Not enough mana",4a,02,dc,b8));
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 168)					int _g5 = (int)0;
HXDLIN( 168)					::Array< ::Dynamic> _g15 = this->observers;
HXDLIN( 168)					while((_g5 < _g15->length)){
HXLINE( 168)						::Dynamic o4 = _g15->__get(_g5);
HXDLIN( 168)						_g5 = (_g5 + (int)1);
HXDLIN( 168)						::battle::IModelObserver_obj::warn(o4,HX_("This ability is currently on cooldown",14,7f,21,9f));
            					}
            				}
            				break;
            				case (int)4: {
HXLINE( 170)					int _g6 = (int)0;
HXDLIN( 170)					::Array< ::Dynamic> _g16 = this->observers;
HXDLIN( 170)					while((_g6 < _g16->length)){
HXLINE( 170)						::Dynamic o5 = _g16->__get(_g6);
HXDLIN( 170)						_g6 = (_g6 + (int)1);
HXDLIN( 170)						::battle::IModelObserver_obj::warn(o5,HX_("This ability is passive, you can't use it",85,c9,df,fe));
            					}
            				}
            				break;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,choose,(void))

void Model_obj::targetAndUse( ::battle::_hx_struct::UnitCoords targetCoords){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_176_targetAndUse)
HXDLIN( 176)		 ::battle::TargetResult _g = this->checkTarget(targetCoords,this->chosenAbilityPos);
HXDLIN( 176)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)0: {
HXLINE( 179)				this->inputMode = ::battle::enums::InputMode_obj::None_dyn();
HXLINE( 181)				{
HXLINE( 181)					int _g1 = (int)0;
HXDLIN( 181)					::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 181)					while((_g1 < _g11->length)){
HXLINE( 181)						::Dynamic o = _g11->__get(_g1);
HXDLIN( 181)						_g1 = (_g1 + (int)1);
HXDLIN( 181)						::battle::IModelObserver_obj::abDeselected(o,this->chosenAbilityPos);
            					}
            				}
HXLINE( 183)				 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::player();
HXDLIN( 183)				this->setUA(targetCoords,_hx_tmp,Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(this->chosenAbilityPos));
HXLINE( 184)				this->useAbility();
            			}
            			break;
            			case (int)1: {
HXLINE( 186)				this->inputMode = ::battle::enums::InputMode_obj::Choosing_dyn();
HXLINE( 188)				{
HXLINE( 188)					int _g2 = (int)0;
HXDLIN( 188)					::Array< ::Dynamic> _g12 = this->observers;
HXDLIN( 188)					while((_g2 < _g12->length)){
HXLINE( 188)						::Dynamic o1 = _g12->__get(_g2);
HXDLIN( 188)						_g2 = (_g2 + (int)1);
HXLINE( 190)						::battle::IModelObserver_obj::warn(o1,HX_("Chosen ability cannot be used on this target",b1,4d,aa,2a));
HXLINE( 191)						::battle::IModelObserver_obj::abDeselected(o1,this->chosenAbilityPos);
            					}
            				}
            			}
            			break;
            			case (int)2: case (int)3: {
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,targetAndUse,(void))

void Model_obj::useAbility(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_204_useAbility)
HXDLIN( 204)		int _g = this->UAiterator++;
HXDLIN( 204)		switch((int)(_g)){
            			case (int)0: {
HXLINE( 207)				this->changeMana(this->UAcaster,this->UAcaster,-(this->UAability->manacost),::battle::enums::Source_obj::God_dyn());
HXLINE( 208)				 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 208)				::String _hx_tmp1 = (this->getUnits()->get(this->UAcaster).StaticCast<  ::battle::Unit >()->name + HX_(" now has ",f0,56,fb,3f));
HXDLIN( 208)				::String _hx_tmp2 = ((_hx_tmp1 + this->getUnits()->get(this->UAcaster).StaticCast<  ::battle::Unit >()->manaPool->value) + HX_(" mana",a7,cc,28,b5));
HXDLIN( 208)				_hx_tmp(_hx_tmp2,hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),208,HX_("battle.Model",d3,ab,e0,43),HX_("useAbility",23,84,14,b0)));
HXLINE( 209)				this->UAability->putOnCooldown();
HXLINE( 211)				this->continuePoint = this->useAbility_dyn();
HXLINE( 212)				{
HXLINE( 212)					int _g1 = (int)0;
HXDLIN( 212)					::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 212)					while((_g1 < _g11->length)){
HXLINE( 212)						::Dynamic o = _g11->__get(_g1);
HXDLIN( 212)						_g1 = (_g1 + (int)1);
HXDLIN( 212)						::battle::IModelObserver_obj::abThrown(o,this->UAtarget,this->UAcaster,this->UAability->id,this->UAability->strikeType,this->UAability->element);
            					}
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 214)				 ::battle::Unit target;
HXLINE( 215)				if (this->UAability->aoe) {
HXLINE( 217)					target = Dynamic( this->units->allied(this->UAtarget)->__get(this->AOECounter)).StaticCast<  ::battle::Unit >();
HXLINE( 218)					this->AOECounter++;
HXLINE( 219)					int _hx_tmp3 = this->AOECounter;
HXDLIN( 219)					if ((_hx_tmp3 < this->units->allied(this->UAtarget)->get_length())) {
HXLINE( 220)						this->UAiterator--;
            					}
            				}
            				else {
HXLINE( 223)					target = this->units->get(this->UAtarget).StaticCast<  ::battle::Unit >();
            				}
HXLINE( 225)				 ::battle::Unit _hx_tmp4 = this->units->get(this->UAcaster).StaticCast<  ::battle::Unit >();
HXDLIN( 225)				if (::battle::Utils_obj::flipMiss(target,_hx_tmp4,this->UAability)) {
HXLINE( 227)					 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 227)					::String _hx_tmp6 = (this->units->get(this->UAcaster).StaticCast<  ::battle::Unit >()->name + HX_(" -> ",6f,2f,49,15));
HXDLIN( 227)					_hx_tmp5(((_hx_tmp6 + target->name) + HX_(": Miss!",1f,2d,e2,d2)),hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),227,HX_("battle.Model",d3,ab,e0,43),HX_("useAbility",23,84,14,b0)));
HXLINE( 228)					{
HXLINE( 228)						int _g2 = (int)0;
HXDLIN( 228)						::Array< ::Dynamic> _g12 = this->observers;
HXDLIN( 228)						while((_g2 < _g12->length)){
HXLINE( 228)							::Dynamic o1 = _g12->__get(_g2);
HXDLIN( 228)							_g2 = (_g2 + (int)1);
HXDLIN( 228)							 ::battle::_hx_struct::UnitCoords _hx_tmp7 = ::battle::_hx_struct::UnitCoords_obj::get(target);
HXDLIN( 228)							::battle::IModelObserver_obj::miss(o1,_hx_tmp7,this->UAability->element);
            						}
            					}
            				}
            				else {
HXLINE( 231)					 ::ID _hx_tmp8 = this->UAability->id;
HXDLIN( 231)					 ::battle::_hx_struct::UnitCoords _hx_tmp9 = ::battle::_hx_struct::UnitCoords_obj::get(target);
HXDLIN( 231)					::battle::data::Abilities_obj::useAbility(_hx_tmp8,_hx_tmp9,this->UAcaster,this->UAability->element);
            				}
HXLINE( 233)				this->continuePoint = this->useAbility_dyn();
HXLINE( 234)				{
HXLINE( 234)					int _g3 = (int)0;
HXDLIN( 234)					::Array< ::Dynamic> _g13 = this->observers;
HXDLIN( 234)					while((_g3 < _g13->length)){
HXLINE( 234)						::Dynamic o2 = _g13->__get(_g3);
HXDLIN( 234)						_g3 = (_g3 + (int)1);
HXDLIN( 234)						 ::battle::_hx_struct::UnitCoords _hx_tmp10 = ::battle::_hx_struct::UnitCoords_obj::get(target);
HXDLIN( 234)						::battle::IModelObserver_obj::abStriked(o2,_hx_tmp10,this->UAcaster,this->UAability->id,this->UAability->strikeType,this->UAability->element);
            					}
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 236)				this->postTurnProcess(this->UAcaster);
            			}
            			break;
            			default:{
HXLINE( 238)				this->UAiterator = (int)0;
HXLINE( 239)				if (this->UAability->aoe) {
HXLINE( 240)					this->AOECounter = (int)0;
            				}
HXLINE( 241)				this->useAbility();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,useAbility,(void))

void Model_obj::setUA( ::battle::_hx_struct::UnitCoords target, ::battle::_hx_struct::UnitCoords caster, ::battle::Active ability){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_246_setUA)
HXLINE( 247)		this->UAtarget = target;
HXLINE( 248)		this->UAcaster = caster;
HXLINE( 249)		this->UAability = ability;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Model_obj,setUA,(void))

void Model_obj::clearUA(){
            	HX_GC_STACKFRAME(&_hx_pos_653930ec9597c981_253_clearUA)
HXLINE( 254)		this->UAtarget = ::battle::_hx_struct::UnitCoords_obj::nullC();
HXLINE( 255)		this->UAcaster = ::battle::_hx_struct::UnitCoords_obj::nullC();
HXLINE( 256)		this->UAability =  ::battle::Active_obj::__alloc( HX_CTX ,::ID_obj::NullID_dyn());
HXLINE( 257)		this->UAiterator = (int)0;
HXLINE( 258)		this->AOECounter = (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,clearUA,(void))

void Model_obj::alacrityIncrement(){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		bool _hx_run( ::battle::Unit u){
            			HX_STACKFRAME(&_hx_pos_653930ec9597c981_267_alacrityIncrement)
HXLINE( 267)			return u->isAlive();
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_266_alacrityIncrement)
HXLINE( 267)		 ::Dynamic alive =  ::Dynamic(new _hx_Closure_0());
HXLINE( 268)		::Array< ::Dynamic> fastest = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 269)		int fastestTurnCount = (int)1000;
HXLINE( 270)		{
HXLINE( 270)			int _g = (int)0;
HXDLIN( 270)			::Array< ::Dynamic> _g1 = this->units->get_both()->filter(alive);
HXDLIN( 270)			while((_g < _g1->length)){
HXLINE( 270)				 ::battle::Unit unit = _g1->__get(_g).StaticCast<  ::battle::Unit >();
HXDLIN( 270)				_g = (_g + (int)1);
HXLINE( 272)				Float turns = (unit->alacrityPool->maxValue - unit->alacrityPool->value);
HXDLIN( 272)				int turns1 = ::Math_obj::ceil(((Float)turns / (Float)this->getAlacrityGain(unit)));
HXLINE( 273)				if ((turns1 < fastestTurnCount)) {
HXLINE( 275)					fastest = ::Array_obj< ::Dynamic>::__new(1)->init(0,unit);
HXLINE( 276)					fastestTurnCount = turns1;
            				}
            				else {
HXLINE( 278)					if ((turns1 == fastestTurnCount)) {
HXLINE( 279)						fastest->push(unit);
            					}
            				}
            			}
            		}
HXLINE( 281)		{
HXLINE( 281)			int _g2 = (int)0;
HXDLIN( 281)			::Array< ::Dynamic> _g11 = this->units->get_both()->filter(alive);
HXDLIN( 281)			while((_g2 < _g11->length)){
HXLINE( 281)				 ::battle::Unit unit1 = _g11->__get(_g2).StaticCast<  ::battle::Unit >();
HXDLIN( 281)				_g2 = (_g2 + (int)1);
HXLINE( 282)				 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::get(unit1);
HXDLIN( 282)				 ::battle::_hx_struct::UnitCoords _hx_tmp1 = ::battle::_hx_struct::UnitCoords_obj::get(unit1);
HXDLIN( 282)				this->changeAlacrity(_hx_tmp,_hx_tmp1,(this->getAlacrityGain(unit1) * fastestTurnCount),::battle::enums::Source_obj::God_dyn());
            			}
            		}
HXLINE( 284)		this->readyUnits = fastest;
HXLINE( 285)		this->processReady();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,alacrityIncrement,(void))

void Model_obj::processReady(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_290_processReady)
HXDLIN( 290)		if (!(::Lambda_obj::empty(this->readyUnits))) {
HXLINE( 292)			int index = ::Math_obj::floor((::Math_obj::random() * this->readyUnits->length));
HXLINE( 293)			 ::battle::Unit unit = this->readyUnits->__get(index).StaticCast<  ::battle::Unit >();
HXLINE( 294)			this->readyUnits = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 295)			 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::get(unit);
HXDLIN( 295)			 ::battle::_hx_struct::UnitCoords _hx_tmp1 = ::battle::_hx_struct::UnitCoords_obj::get(unit);
HXDLIN( 295)			this->changeAlacrity(_hx_tmp,_hx_tmp1,-(unit->alacrityPool->value),::battle::enums::Source_obj::God_dyn());
HXLINE( 297)			bool _hx_tmp2;
HXDLIN( 297)			if (!(unit->isStunned())) {
HXLINE( 297)				_hx_tmp2 = this->checkAlive(::Array_obj< ::Dynamic>::__new(1)->init(0,unit));
            			}
            			else {
HXLINE( 297)				_hx_tmp2 = false;
            			}
HXDLIN( 297)			if (_hx_tmp2) {
HXLINE( 298)				bool _hx_tmp3;
HXDLIN( 298)				if (hx::IsEq( unit->team,::battle::enums::Team_obj::Left_dyn() )) {
HXLINE( 298)					_hx_tmp3 = (unit->position == (int)0);
            				}
            				else {
HXLINE( 298)					_hx_tmp3 = false;
            				}
HXDLIN( 298)				if (_hx_tmp3) {
HXLINE( 299)					this->inputMode = ::battle::enums::InputMode_obj::Choosing_dyn();
            				}
            				else {
HXLINE( 301)					this->botMakeTurn(unit);
            				}
            			}
            			else {
HXLINE( 303)				this->postTurnProcess(::battle::_hx_struct::UnitCoords_obj::get(unit));
            			}
            		}
            		else {
HXLINE( 306)			HX_STACK_DO_THROW(HX_("Trying to process empty readyUnits array",55,64,cc,9d));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,processReady,(void))

void Model_obj::postTurnProcess( ::battle::_hx_struct::UnitCoords coords){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_310_postTurnProcess)
HXLINE( 311)		 ::battle::Unit unit = this->units->get(coords).StaticCast<  ::battle::Unit >();
HXLINE( 313)		if (!(this->bothTeamsAlive())) {
HXLINE( 315)			this->end(this->defineWinner());
HXLINE( 316)			return;
            		}
HXLINE( 319)		if (unit->isAlive()) {
HXLINE( 321)			{
HXLINE( 321)				int _g = (int)0;
HXDLIN( 321)				::Array< ::Dynamic> _g1 = this->observers;
HXDLIN( 321)				while((_g < _g1->length)){
HXLINE( 321)					::Dynamic o = _g1->__get(_g);
HXDLIN( 321)					_g = (_g + (int)1);
HXDLIN( 321)					::battle::IModelObserver_obj::preTick(o,unit);
            				}
            			}
HXLINE( 322)			unit->tick();
HXLINE( 323)			{
HXLINE( 323)				int _g2 = (int)0;
HXDLIN( 323)				::Array< ::Dynamic> _g11 = this->observers;
HXDLIN( 323)				while((_g2 < _g11->length)){
HXLINE( 323)					::Dynamic o1 = _g11->__get(_g2);
HXDLIN( 323)					_g2 = (_g2 + (int)1);
HXDLIN( 323)					::battle::IModelObserver_obj::tick(o1,unit);
            				}
            			}
            		}
HXLINE( 326)		if (!(this->bothTeamsAlive())) {
HXLINE( 328)			this->end(this->defineWinner());
HXLINE( 329)			return;
            		}
HXLINE( 332)		this->alacrityIncrement();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,postTurnProcess,(void))

void Model_obj::botMakeTurn( ::battle::Unit bot){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_336_botMakeTurn)
HXLINE( 337)		 ::Dynamic decision = ::battle::data::Units_obj::decide(bot->id);
HXLINE( 339)		 ::battle::_hx_struct::UnitCoords decision1 = ( ( ::battle::_hx_struct::UnitCoords)(decision->__Field(HX_("target",51,f3,ec,86),hx::paccDynamic)) );
HXDLIN( 339)		 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::get(bot);
HXDLIN( 339)		this->setUA(decision1,_hx_tmp,bot->wheel->getActive(( (int)(decision->__Field(HX_("abilityNum",bc,1a,8b,b3),hx::paccDynamic)) )));
HXLINE( 340)		this->useAbility();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,botMakeTurn,(void))

Float Model_obj::getAlacrityGain( ::battle::Unit unit){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_344_getAlacrityGain)
HXLINE( 345)		Float sum = (int)0;
HXLINE( 346)		{
HXLINE( 346)			int _g = (int)0;
HXDLIN( 346)			::Array< ::Dynamic> _g1 = this->units->get_both();
HXDLIN( 346)			while((_g < _g1->length)){
HXLINE( 346)				 ::battle::Unit u = _g1->__get(_g).StaticCast<  ::battle::Unit >();
HXDLIN( 346)				_g = (_g + (int)1);
HXLINE( 347)				if (this->checkAlive(::Array_obj< ::Dynamic>::__new(1)->init(0,u))) {
HXLINE( 348)					sum = (sum + u->flow);
            				}
            			}
            		}
HXLINE( 350)		return ((Float)unit->flow / (Float)sum);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,getAlacrityGain,return )

void Model_obj::end( ::battle::enums::Team winner){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_358_end)
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,end,(void))

 ::battle::enums::Team Model_obj::defineWinner(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_364_defineWinner)
HXDLIN( 364)		if (this->checkAlive(this->units->left)) {
HXLINE( 365)			return ::battle::enums::Team_obj::Left_dyn();
            		}
            		else {
HXLINE( 366)			if (this->checkAlive(this->units->right)) {
HXLINE( 367)				return ::battle::enums::Team_obj::Right_dyn();
            			}
            			else {
HXLINE( 369)				return null();
            			}
            		}
HXLINE( 364)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,defineWinner,return )

bool Model_obj::checkAlive(::Array< ::Dynamic> array){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_373_checkAlive)
HXLINE( 374)		{
HXLINE( 374)			int _g = (int)0;
HXDLIN( 374)			while((_g < array->length)){
HXLINE( 374)				 ::battle::Unit unit = array->__get(_g).StaticCast<  ::battle::Unit >();
HXDLIN( 374)				_g = (_g + (int)1);
HXLINE( 375)				if (unit->isAlive()) {
HXLINE( 376)					return true;
            				}
            			}
            		}
HXLINE( 377)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,checkAlive,return )

bool Model_obj::bothTeamsAlive(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_382_bothTeamsAlive)
HXDLIN( 382)		if (this->checkAlive(this->units->left)) {
HXDLIN( 382)			return this->checkAlive(this->units->right);
            		}
            		else {
HXDLIN( 382)			return false;
            		}
HXDLIN( 382)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,bothTeamsAlive,return )

void Model_obj::skipTurn(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_391_skipTurn)
HXDLIN( 391)		if (hx::IsNotEq( this->inputMode,::battle::enums::InputMode_obj::None_dyn() )) {
HXLINE( 393)			this->inputMode = ::battle::enums::InputMode_obj::None_dyn();
HXLINE( 394)			 ::battle::_hx_struct::UnitCoords _hx_tmp = ::battle::_hx_struct::UnitCoords_obj::player();
HXDLIN( 394)			this->changeAlacrity(_hx_tmp,::battle::_hx_struct::UnitCoords_obj::player(),(int)-100,::battle::enums::Source_obj::God_dyn());
HXLINE( 395)			this->postTurnProcess(::battle::_hx_struct::UnitCoords_obj::player());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,skipTurn,(void))

void Model_obj::quit(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_401_quit)
HXDLIN( 401)		this->end(::battle::enums::Team_obj::Right_dyn());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,quit,(void))

void Model_obj::addObserver(::Dynamic obs){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_409_addObserver)
HXLINE( 410)		this->observers->push(obs);
HXLINE( 411)		this->responsesLeft++;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,addObserver,(void))

void Model_obj::respond(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_416_respond)
HXDLIN( 416)		if ((this->responsesLeft == (int)0)) {
HXLINE( 417)			::haxe::Log_obj::trace(HX_("WARN//Unexpected response",6a,65,bf,ea),hx::SourceInfo(HX_("Model.hx",d5,ca,a9,a6),417,HX_("battle.Model",d3,ab,e0,43),HX_("respond",55,89,0b,68)));
            		}
            		else {
HXLINE( 418)			if ((--this->responsesLeft == (int)0)) {
HXLINE( 420)				::cpp::VirtualArray args = this->continueArgs;
HXLINE( 421)				 ::Dynamic point = this->continuePoint;
HXLINE( 422)				this->continuePoint = null();
HXLINE( 423)				this->continueArgs = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 424)				this->responsesLeft = this->observers->length;
HXLINE( 426)				::Reflect_obj::callMethod(point,point,args);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,respond,(void))

 ::battle::ChooseResult Model_obj::checkChoose(int abilityPos){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_435_checkChoose)
HXLINE( 436)		 ::battle::Ability ability = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->get(abilityPos);
HXLINE( 438)		bool _hx_tmp;
HXDLIN( 438)		if (hx::IsNotEq( ability->id,::ID_obj::EmptyAbility_dyn() )) {
HXLINE( 438)			_hx_tmp = hx::IsEq( ability->id,::ID_obj::LockAbility_dyn() );
            		}
            		else {
HXLINE( 438)			_hx_tmp = true;
            		}
HXDLIN( 438)		if (_hx_tmp) {
HXLINE( 439)			return ::battle::ChooseResult_obj::Empty_dyn();
            		}
HXLINE( 440)		if (hx::IsEq( ability->type,::battle::enums::AbilityType_obj::Passive_dyn() )) {
HXLINE( 441)			return ::battle::ChooseResult_obj::Passive_dyn();
            		}
HXLINE( 443)		 ::battle::Active activeAbility = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(abilityPos);
HXLINE( 445)		if ((activeAbility->_cooldown->value > (int)0)) {
HXLINE( 446)			return ::battle::ChooseResult_obj::Cooldown_dyn();
            		}
HXLINE( 447)		 ::battle::Unit _this = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >();
HXDLIN( 447)		int _this1 = _this->manaPool->value;
HXDLIN( 447)		if ((_this1 < _this->wheel->getActive(abilityPos)->manacost)) {
HXLINE( 448)			return ::battle::ChooseResult_obj::Manacost_dyn();
            		}
HXLINE( 450)		return ::battle::ChooseResult_obj::Ok_dyn();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,checkChoose,return )

 ::battle::TargetResult Model_obj::checkTarget( ::battle::_hx_struct::UnitCoords targetCoords,int abilityPos){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_454_checkTarget)
HXLINE( 455)		 ::battle::Unit target = this->units->get(targetCoords).StaticCast<  ::battle::Unit >();
HXLINE( 456)		 ::battle::Active ability = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->wheel->getActive(abilityPos);
HXLINE( 458)		if (hx::IsNull( target )) {
HXLINE( 459)			return ::battle::TargetResult_obj::Nonexistent_dyn();
            		}
HXLINE( 460)		if ((target->hpPool->value == (int)0)) {
HXLINE( 461)			return ::battle::TargetResult_obj::Dead_dyn();
            		}
HXLINE( 462)		 ::battle::enums::UnitType relation = Dynamic( this->units->left->__get((int)0)).StaticCast<  ::battle::Unit >()->figureRelation(target);
HXDLIN( 462)		bool _hx_tmp;
HXDLIN( 462)		 ::battle::enums::AbilityTarget _g = ability->possibleTarget;
HXDLIN( 462)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)0: {
HXLINE( 462)				_hx_tmp = hx::IsEq( relation,::battle::enums::UnitType_obj::Self_dyn() );
            			}
            			break;
            			case (int)1: {
HXLINE( 462)				if (hx::IsNotEq( relation,::battle::enums::UnitType_obj::Ally_dyn() )) {
HXLINE( 462)					_hx_tmp = hx::IsEq( relation,::battle::enums::UnitType_obj::Self_dyn() );
            				}
            				else {
HXLINE( 462)					_hx_tmp = true;
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 462)				_hx_tmp = hx::IsEq( relation,::battle::enums::UnitType_obj::Enemy_dyn() );
            			}
            			break;
            			case (int)3: {
HXLINE( 462)				_hx_tmp = true;
            			}
            			break;
            		}
HXDLIN( 462)		if (!(_hx_tmp)) {
HXLINE( 463)			return ::battle::TargetResult_obj::Invalid_dyn();
            		}
HXLINE( 465)		return ::battle::TargetResult_obj::Ok_dyn();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Model_obj,checkTarget,return )

bool Model_obj::targetAvaibility( ::battle::_hx_struct::UnitCoords unit){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_470_targetAvaibility)
HXDLIN( 470)		if (::MathUtils_obj::inRange(this->chosenAbilityPos,(int)0,(int)7,null(),null())) {
HXLINE( 471)			return hx::IsEq( this->checkTarget(unit,this->chosenAbilityPos),::battle::TargetResult_obj::Ok_dyn() );
            		}
            		else {
HXLINE( 473)			return false;
            		}
HXLINE( 470)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Model_obj,targetAvaibility,return )

void Model_obj::init(){
            	HX_STACKFRAME(&_hx_pos_653930ec9597c981_491_init)
HXLINE( 492)		::battle::data::Abilities_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 493)		::battle::data::Units_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 494)		::battle::data::Buffs_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 495)		::battle::data::Passives_obj::init(hx::ObjectPtr<OBJ_>(this));
HXLINE( 496)		this->alacrityIncrement();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Model_obj,init,(void))


hx::ObjectPtr< Model_obj > Model_obj::__new(::Array< ::Dynamic> allies,::Array< ::Dynamic> enemies) {
	hx::ObjectPtr< Model_obj > __this = new Model_obj();
	__this->__construct(allies,enemies);
	return __this;
}

hx::ObjectPtr< Model_obj > Model_obj::__alloc(hx::Ctx *_hx_ctx,::Array< ::Dynamic> allies,::Array< ::Dynamic> enemies) {
	Model_obj *__this = (Model_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Model_obj), true, "battle.Model"));
	*(void **)__this = Model_obj::_hx_vtable;
	__this->__construct(allies,enemies);
	return __this;
}

Model_obj::Model_obj()
{
}

void Model_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Model);
	HX_MARK_MEMBER_NAME(observers,"observers");
	HX_MARK_MEMBER_NAME(units,"units");
	HX_MARK_MEMBER_NAME(inputMode,"inputMode");
	HX_MARK_MEMBER_NAME(chosenAbilityPos,"chosenAbilityPos");
	HX_MARK_MEMBER_NAME(UAtarget,"UAtarget");
	HX_MARK_MEMBER_NAME(UAcaster,"UAcaster");
	HX_MARK_MEMBER_NAME(UAability,"UAability");
	HX_MARK_MEMBER_NAME(UAiterator,"UAiterator");
	HX_MARK_MEMBER_NAME(AOECounter,"AOECounter");
	HX_MARK_MEMBER_NAME(responsesLeft,"responsesLeft");
	HX_MARK_MEMBER_NAME(continuePoint,"continuePoint");
	HX_MARK_MEMBER_NAME(continueArgs,"continueArgs");
	HX_MARK_MEMBER_NAME(readyUnits,"readyUnits");
	HX_MARK_END_CLASS();
}

void Model_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(observers,"observers");
	HX_VISIT_MEMBER_NAME(units,"units");
	HX_VISIT_MEMBER_NAME(inputMode,"inputMode");
	HX_VISIT_MEMBER_NAME(chosenAbilityPos,"chosenAbilityPos");
	HX_VISIT_MEMBER_NAME(UAtarget,"UAtarget");
	HX_VISIT_MEMBER_NAME(UAcaster,"UAcaster");
	HX_VISIT_MEMBER_NAME(UAability,"UAability");
	HX_VISIT_MEMBER_NAME(UAiterator,"UAiterator");
	HX_VISIT_MEMBER_NAME(AOECounter,"AOECounter");
	HX_VISIT_MEMBER_NAME(responsesLeft,"responsesLeft");
	HX_VISIT_MEMBER_NAME(continuePoint,"continuePoint");
	HX_VISIT_MEMBER_NAME(continueArgs,"continueArgs");
	HX_VISIT_MEMBER_NAME(readyUnits,"readyUnits");
}

hx::Val Model_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return hx::Val( end_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"quit") ) { return hx::Val( quit_dyn() ); }
		if (HX_FIELD_EQ(inName,"init") ) { return hx::Val( init_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"units") ) { return hx::Val( units ); }
		if (HX_FIELD_EQ(inName,"setUA") ) { return hx::Val( setUA_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"choose") ) { return hx::Val( choose_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"clearUA") ) { return hx::Val( clearUA_dyn() ); }
		if (HX_FIELD_EQ(inName,"respond") ) { return hx::Val( respond_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"UAtarget") ) { return hx::Val( UAtarget ); }
		if (HX_FIELD_EQ(inName,"UAcaster") ) { return hx::Val( UAcaster ); }
		if (HX_FIELD_EQ(inName,"getUnits") ) { return hx::Val( getUnits_dyn() ); }
		if (HX_FIELD_EQ(inName,"changeHP") ) { return hx::Val( changeHP_dyn() ); }
		if (HX_FIELD_EQ(inName,"castBuff") ) { return hx::Val( castBuff_dyn() ); }
		if (HX_FIELD_EQ(inName,"skipTurn") ) { return hx::Val( skipTurn_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"observers") ) { return hx::Val( observers ); }
		if (HX_FIELD_EQ(inName,"inputMode") ) { return hx::Val( inputMode ); }
		if (HX_FIELD_EQ(inName,"UAability") ) { return hx::Val( UAability ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"UAiterator") ) { return hx::Val( UAiterator ); }
		if (HX_FIELD_EQ(inName,"AOECounter") ) { return hx::Val( AOECounter ); }
		if (HX_FIELD_EQ(inName,"readyUnits") ) { return hx::Val( readyUnits ); }
		if (HX_FIELD_EQ(inName,"changeMana") ) { return hx::Val( changeMana_dyn() ); }
		if (HX_FIELD_EQ(inName,"useAbility") ) { return hx::Val( useAbility_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkAlive") ) { return hx::Val( checkAlive_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"botMakeTurn") ) { return hx::Val( botMakeTurn_dyn() ); }
		if (HX_FIELD_EQ(inName,"addObserver") ) { return hx::Val( addObserver_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkChoose") ) { return hx::Val( checkChoose_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkTarget") ) { return hx::Val( checkTarget_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"continueArgs") ) { return hx::Val( continueArgs ); }
		if (HX_FIELD_EQ(inName,"getInputMode") ) { return hx::Val( getInputMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"dispellBuffs") ) { return hx::Val( dispellBuffs_dyn() ); }
		if (HX_FIELD_EQ(inName,"targetAndUse") ) { return hx::Val( targetAndUse_dyn() ); }
		if (HX_FIELD_EQ(inName,"processReady") ) { return hx::Val( processReady_dyn() ); }
		if (HX_FIELD_EQ(inName,"defineWinner") ) { return hx::Val( defineWinner_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"responsesLeft") ) { return hx::Val( responsesLeft ); }
		if (HX_FIELD_EQ(inName,"continuePoint") ) { return hx::Val( continuePoint ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"changeAlacrity") ) { return hx::Val( changeAlacrity_dyn() ); }
		if (HX_FIELD_EQ(inName,"bothTeamsAlive") ) { return hx::Val( bothTeamsAlive_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"postTurnProcess") ) { return hx::Val( postTurnProcess_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAlacrityGain") ) { return hx::Val( getAlacrityGain_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"chosenAbilityPos") ) { return hx::Val( chosenAbilityPos ); }
		if (HX_FIELD_EQ(inName,"targetAvaibility") ) { return hx::Val( targetAvaibility_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"alacrityIncrement") ) { return hx::Val( alacrityIncrement_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Model_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"units") ) { units=inValue.Cast<  ::battle::_hx_struct::UPair >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"UAtarget") ) { UAtarget=inValue.Cast<  ::battle::_hx_struct::UnitCoords >(); return inValue; }
		if (HX_FIELD_EQ(inName,"UAcaster") ) { UAcaster=inValue.Cast<  ::battle::_hx_struct::UnitCoords >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"observers") ) { observers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"inputMode") ) { inputMode=inValue.Cast<  ::battle::enums::InputMode >(); return inValue; }
		if (HX_FIELD_EQ(inName,"UAability") ) { UAability=inValue.Cast<  ::battle::Active >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"UAiterator") ) { UAiterator=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"AOECounter") ) { AOECounter=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"readyUnits") ) { readyUnits=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"continueArgs") ) { continueArgs=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"responsesLeft") ) { responsesLeft=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"continuePoint") ) { continuePoint=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"chosenAbilityPos") ) { chosenAbilityPos=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Model_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("observers","\x9d","\x57","\x26","\x5e"));
	outFields->push(HX_HCSTRING("units","\x6f","\x69","\xe7","\xa6"));
	outFields->push(HX_HCSTRING("inputMode","\x8d","\x90","\x8b","\x0f"));
	outFields->push(HX_HCSTRING("chosenAbilityPos","\x5c","\x48","\xce","\x46"));
	outFields->push(HX_HCSTRING("UAtarget","\x9d","\xfe","\x9f","\x13"));
	outFields->push(HX_HCSTRING("UAcaster","\x38","\xf0","\x41","\x48"));
	outFields->push(HX_HCSTRING("UAability","\xde","\x38","\x58","\x3d"));
	outFields->push(HX_HCSTRING("UAiterator","\x3a","\xc0","\x9f","\xfb"));
	outFields->push(HX_HCSTRING("AOECounter","\x25","\x70","\xab","\x40"));
	outFields->push(HX_HCSTRING("responsesLeft","\xf9","\x07","\xe4","\x88"));
	outFields->push(HX_HCSTRING("continuePoint","\x69","\x6e","\x8a","\xd2"));
	outFields->push(HX_HCSTRING("continueArgs","\x64","\x59","\x4c","\xf1"));
	outFields->push(HX_HCSTRING("readyUnits","\x0c","\xf2","\x2a","\x60"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Model_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< ::battle::IModelObserver >*/ ,(int)offsetof(Model_obj,observers),HX_HCSTRING("observers","\x9d","\x57","\x26","\x5e")},
	{hx::fsObject /*::battle::_hx_struct::UPair*/ ,(int)offsetof(Model_obj,units),HX_HCSTRING("units","\x6f","\x69","\xe7","\xa6")},
	{hx::fsObject /*::battle::enums::InputMode*/ ,(int)offsetof(Model_obj,inputMode),HX_HCSTRING("inputMode","\x8d","\x90","\x8b","\x0f")},
	{hx::fsInt,(int)offsetof(Model_obj,chosenAbilityPos),HX_HCSTRING("chosenAbilityPos","\x5c","\x48","\xce","\x46")},
	{hx::fsObject /*::battle::_hx_struct::UnitCoords*/ ,(int)offsetof(Model_obj,UAtarget),HX_HCSTRING("UAtarget","\x9d","\xfe","\x9f","\x13")},
	{hx::fsObject /*::battle::_hx_struct::UnitCoords*/ ,(int)offsetof(Model_obj,UAcaster),HX_HCSTRING("UAcaster","\x38","\xf0","\x41","\x48")},
	{hx::fsObject /*::battle::Active*/ ,(int)offsetof(Model_obj,UAability),HX_HCSTRING("UAability","\xde","\x38","\x58","\x3d")},
	{hx::fsInt,(int)offsetof(Model_obj,UAiterator),HX_HCSTRING("UAiterator","\x3a","\xc0","\x9f","\xfb")},
	{hx::fsInt,(int)offsetof(Model_obj,AOECounter),HX_HCSTRING("AOECounter","\x25","\x70","\xab","\x40")},
	{hx::fsInt,(int)offsetof(Model_obj,responsesLeft),HX_HCSTRING("responsesLeft","\xf9","\x07","\xe4","\x88")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Model_obj,continuePoint),HX_HCSTRING("continuePoint","\x69","\x6e","\x8a","\xd2")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(Model_obj,continueArgs),HX_HCSTRING("continueArgs","\x64","\x59","\x4c","\xf1")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Model_obj,readyUnits),HX_HCSTRING("readyUnits","\x0c","\xf2","\x2a","\x60")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Model_obj_sStaticStorageInfo = 0;
#endif

static ::String Model_obj_sMemberFields[] = {
	HX_HCSTRING("observers","\x9d","\x57","\x26","\x5e"),
	HX_HCSTRING("units","\x6f","\x69","\xe7","\xa6"),
	HX_HCSTRING("inputMode","\x8d","\x90","\x8b","\x0f"),
	HX_HCSTRING("chosenAbilityPos","\x5c","\x48","\xce","\x46"),
	HX_HCSTRING("UAtarget","\x9d","\xfe","\x9f","\x13"),
	HX_HCSTRING("UAcaster","\x38","\xf0","\x41","\x48"),
	HX_HCSTRING("UAability","\xde","\x38","\x58","\x3d"),
	HX_HCSTRING("UAiterator","\x3a","\xc0","\x9f","\xfb"),
	HX_HCSTRING("AOECounter","\x25","\x70","\xab","\x40"),
	HX_HCSTRING("responsesLeft","\xf9","\x07","\xe4","\x88"),
	HX_HCSTRING("continuePoint","\x69","\x6e","\x8a","\xd2"),
	HX_HCSTRING("continueArgs","\x64","\x59","\x4c","\xf1"),
	HX_HCSTRING("readyUnits","\x0c","\xf2","\x2a","\x60"),
	HX_HCSTRING("getUnits","\xf9","\x78","\xbe","\x06"),
	HX_HCSTRING("getInputMode","\x17","\x2d","\xe2","\x1e"),
	HX_HCSTRING("changeHP","\x78","\x0c","\x4e","\x66"),
	HX_HCSTRING("changeMana","\x17","\x72","\x9f","\x22"),
	HX_HCSTRING("changeAlacrity","\x99","\x67","\x5a","\xa5"),
	HX_HCSTRING("castBuff","\x32","\x20","\xa3","\xd1"),
	HX_HCSTRING("dispellBuffs","\x3d","\xb0","\xa8","\xcd"),
	HX_HCSTRING("choose","\xd7","\x5a","\xb4","\xc0"),
	HX_HCSTRING("targetAndUse","\xe1","\x43","\x90","\x1d"),
	HX_HCSTRING("useAbility","\x23","\x84","\x14","\xb0"),
	HX_HCSTRING("setUA","\x6e","\x92","\x2f","\x7a"),
	HX_HCSTRING("clearUA","\x19","\xf9","\x44","\xab"),
	HX_HCSTRING("alacrityIncrement","\xe6","\xb2","\x1b","\x86"),
	HX_HCSTRING("processReady","\x74","\x3b","\x6f","\xce"),
	HX_HCSTRING("postTurnProcess","\xf2","\xa7","\x40","\x24"),
	HX_HCSTRING("botMakeTurn","\xb2","\x39","\x28","\x68"),
	HX_HCSTRING("getAlacrityGain","\xde","\xd4","\xb9","\x9c"),
	HX_HCSTRING("end","\xdb","\x03","\x4d","\x00"),
	HX_HCSTRING("defineWinner","\x5a","\x70","\x04","\x2c"),
	HX_HCSTRING("checkAlive","\xe5","\x65","\x81","\x31"),
	HX_HCSTRING("bothTeamsAlive","\x98","\x76","\x21","\x4c"),
	HX_HCSTRING("skipTurn","\x9c","\xd9","\x5a","\xc3"),
	HX_HCSTRING("quit","\xcf","\x3f","\x0a","\x4b"),
	HX_HCSTRING("addObserver","\x57","\x73","\xaa","\x57"),
	HX_HCSTRING("respond","\x55","\x89","\x0b","\x68"),
	HX_HCSTRING("checkChoose","\xbf","\x2d","\xc6","\xa2"),
	HX_HCSTRING("checkTarget","\x39","\xc6","\xfe","\x68"),
	HX_HCSTRING("targetAvaibility","\x17","\xce","\x73","\x80"),
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	::String(null()) };

static void Model_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Model_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Model_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Model_obj::__mClass,"__mClass");
};

#endif

hx::Class Model_obj::__mClass;

void Model_obj::__register()
{
	hx::Object *dummy = new Model_obj;
	Model_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("battle.Model","\xd3","\xab","\xe0","\x43");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Model_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Model_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Model_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Model_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Model_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Model_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace battle
